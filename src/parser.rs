#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(unknown_lints)]
#![allow(ellipsis_inclusive_range_patterns)]
// Generated by rust-peg. Do not edit.
use self::RuleResult::{Failed, Matched};
use ast::*;
use astutil::*;
use env::{Env, Symbol};
use interner::Interner;
use span::{Node, Span};
fn escape_default(s: &str) -> String {
    s.chars().flat_map(|c| c.escape_default()).collect()
}
fn char_range_at(s: &str, pos: usize) -> (char, usize) {
    let c = &s[pos..].chars().next().unwrap();
    let next_pos = pos + c.len_utf8();
    (*c, next_pos)
}
#[derive(Clone)]
enum RuleResult<T> {
    Matched(usize, T),
    Failed,
}
#[derive(PartialEq, Eq, Debug, Clone)]
pub struct ParseError {
    pub line: usize,
    pub column: usize,
    pub offset: usize,
    pub expected: ::std::collections::HashSet<&'static str>,
}
pub type ParseResult<T> = Result<T, ParseError>;
impl ::std::fmt::Display for ParseError {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::result::Result<(), ::std::fmt::Error> {
        try!(write!(fmt, "error at {}:{}: expected ", self.line, self.column));
        if self.expected.len() == 0 {
            try!(write!(fmt, "EOF"));
        } else if self.expected.len() == 1 {
            try!(write!(fmt, "`{}`", escape_default(self.expected.iter().next().unwrap())));
        } else {
            let mut iter = self.expected.iter();
            try!(write!(fmt, "one of `{}`", escape_default(iter.next().unwrap())));
            for elem in iter {
                try!(write!(fmt, ", `{}`", escape_default(elem)));
            }
        }
        Ok(())
    }
}
impl ::std::error::Error for ParseError {
    fn description(&self) -> &str {
        "parse error"
    }
}
fn slice_eq<T: Interner>(input: &str, state: &mut ParseState<T>, pos: usize, m: &'static str) -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let l = m.len();
    if input.len() >= pos + l && &input.as_bytes()[pos..pos + l] == m.as_bytes() {
        Matched(pos + l, ())
    } else {
        state.mark_failure(pos, m)
    }
}
fn slice_eq_case_insensitive<T: Interner>(input: &str, state: &mut ParseState<T>, pos: usize, m: &'static str) -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let mut used = 0usize;
    let mut input_iter = input[pos..].chars().flat_map(|x| x.to_uppercase());
    for m_char_upper in m.chars().flat_map(|x| x.to_uppercase()) {
        used += m_char_upper.len_utf8();
        let input_char_result = input_iter.next();
        if input_char_result.is_none() || input_char_result.unwrap() != m_char_upper {
            return state.mark_failure(pos, m);
        }
    }
    Matched(pos + used, ())
}
fn any_char<T: Interner>(input: &str, state: &mut ParseState<T>, pos: usize) -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    if input.len() > pos {
        let (_, next) = char_range_at(input, pos);
        Matched(next, ())
    } else {
        state.mark_failure(pos, "<character>")
    }
}
fn pos_to_line(input: &str, pos: usize) -> (usize, usize) {
    let before = &input[..pos];
    let line = before.as_bytes().iter().filter(|&&c| c == b'\n').count() + 1;
    let col = before.chars().rev().take_while(|&c| c != '\n').count() + 1;
    (line, col)
}
impl<'input, T: Interner> ParseState<'input, T> {
    fn mark_failure(&mut self, pos: usize, expected: &'static str) -> RuleResult<()> {
        if self.suppress_fail == 0 {
            if pos > self.max_err_pos {
                self.max_err_pos = pos;
                self.expected.clear();
            }
            if pos == self.max_err_pos {
                self.expected.insert(expected);
            }
        }
        Failed
    }
}
struct ParseState<'input, T: Interner> {
    max_err_pos: usize,
    suppress_fail: usize,
    expected: ::std::collections::HashSet<&'static str>,
    _phantom: ::std::marker::PhantomData<&'input ()>,
    postfix_expression0_cache: ::std::collections::HashMap<usize, RuleResult<Expression<T::Interned>>>,
}
impl<'input, T: Interner> ParseState<'input, T> {
    fn new() -> ParseState<'input, T> {
        ParseState { max_err_pos: 0, suppress_fail: 0, expected: ::std::collections::HashSet::new(), _phantom: ::std::marker::PhantomData, postfix_expression0_cache: ::std::collections::HashMap::new() }
    }
}

fn __parse__<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        __state.suppress_fail += 1;
        let res = {
            let mut __repeat_pos = __pos;
            loop {
                let __pos = __repeat_pos;
                let __step_res = {
                    let __choice_res = {
                        let __seq_res = match slice_eq(__input, __state, __pos, "\r") {
                            Matched(__newpos, _) => Matched(__newpos, ()),
                            Failed => Matched(__pos, ()),
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = slice_eq(__input, __state, __pos, "\n");
                                match __seq_res {
                                    Matched(__pos, _) => match __parse_directive(__input, __state, __pos, env) {
                                        Matched(__newpos, _) => Matched(__newpos, ()),
                                        Failed => Matched(__pos, ()),
                                    },
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    };
                    match __choice_res {
                        Matched(__pos, __value) => Matched(__pos, __value),
                        Failed => {
                            if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    ' ' | '\t' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[ \t]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[ \t]")
                            }
                        }
                    }
                };
                match __step_res {
                    Matched(__newpos, __value) => {
                        __repeat_pos = __newpos;
                    }
                    Failed => {
                        break;
                    }
                }
            }
            Matched(__repeat_pos, ())
        };
        __state.suppress_fail -= 1;
        res
    }
}

fn __parse_directive<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "#");
        match __seq_res {
            Matched(__pos, _) => {
                let mut __repeat_pos = __pos;
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = if __input.len() > __pos {
                        let (__ch, __next) = char_range_at(__input, __pos);
                        match __ch {
                            '\n' => __state.mark_failure(__pos, "[^\n]"),
                            _ => Matched(__next, ()),
                        }
                    } else {
                        __state.mark_failure(__pos, "[^\n]")
                    };
                    match __step_res {
                        Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                        }
                        Failed => {
                            break;
                        }
                    }
                }
                Matched(__repeat_pos, ())
            }
            Failed => Failed,
        }
    }
}

fn __parse_identifier<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<Identifier<T::Interned>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = Matched(__pos, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse_identifier0(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = Matched(__pos, __pos);
                        match __seq_res {
                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_identifier0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Identifier<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let str_start = __pos;
            match {
                let __seq_res = if __input.len() > __pos {
                    let (__ch, __next) = char_range_at(__input, __pos);
                    match __ch {
                        '_' | 'a'...'z' | 'A'...'Z' => Matched(__next, ()),
                        _ => __state.mark_failure(__pos, "[_a-zA-Z]"),
                    }
                } else {
                    __state.mark_failure(__pos, "[_a-zA-Z]")
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let mut __repeat_pos = __pos;
                        loop {
                            let __pos = __repeat_pos;
                            let __step_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                            };
                            match __step_res {
                                Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                }
                                Failed => {
                                    break;
                                }
                            }
                        }
                        Matched(__repeat_pos, ())
                    }
                    Failed => Failed,
                }
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, n) => {
                match {
                    if !env.reserved.contains(n) {
                        Ok(Identifier { name: env.interner.intern_str(n) })
                    } else {
                        Err("identifier")
                    }
                } {
                    Ok(res) => Matched(__pos, res),
                    Err(expected) => {
                        __state.mark_failure(__pos, expected);
                        Failed
                    }
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_ohx<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "0");
        match __seq_res {
            Matched(__pos, _) => {
                if __input.len() > __pos {
                    let (__ch, __next) = char_range_at(__input, __pos);
                    match __ch {
                        'x' | 'X' => Matched(__next, ()),
                        _ => __state.mark_failure(__pos, "[xX]"),
                    }
                } else {
                    __state.mark_failure(__pos, "[xX]")
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_obb<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "0");
        match __seq_res {
            Matched(__pos, _) => {
                if __input.len() > __pos {
                    let (__ch, __next) = char_range_at(__input, __pos);
                    match __ch {
                        'b' | 'B' => Matched(__next, ()),
                        _ => __state.mark_failure(__pos, "[bB]"),
                    }
                } else {
                    __state.mark_failure(__pos, "[bB]")
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_dec<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    if __input.len() > __pos {
        let (__ch, __next) = char_range_at(__input, __pos);
        match __ch {
            '0'...'9' => Matched(__next, ()),
            _ => __state.mark_failure(__pos, "[0-9]"),
        }
    } else {
        __state.mark_failure(__pos, "[0-9]")
    }
}

fn __parse_oct<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    if __input.len() > __pos {
        let (__ch, __next) = char_range_at(__input, __pos);
        match __ch {
            '0'...'7' => Matched(__next, ()),
            _ => __state.mark_failure(__pos, "[0-7]"),
        }
    } else {
        __state.mark_failure(__pos, "[0-7]")
    }
}

fn __parse_hex<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    if __input.len() > __pos {
        let (__ch, __next) = char_range_at(__input, __pos);
        match __ch {
            '0'...'9' | 'a'...'f' | 'A'...'F' => Matched(__next, ()),
            _ => __state.mark_failure(__pos, "[0-9a-fA-F]"),
        }
    } else {
        __state.mark_failure(__pos, "[0-9a-fA-F]")
    }
}

fn __parse_bin<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    if __input.len() > __pos {
        let (__ch, __next) = char_range_at(__input, __pos);
        match __ch {
            '0'...'1' => Matched(__next, ()),
            _ => __state.mark_failure(__pos, "[0-1]"),
        }
    } else {
        __state.mark_failure(__pos, "[0-1]")
    }
}

fn __parse_constant<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Constant> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                __state.suppress_fail += 1;
                let __assert_res = if __input.len() > __pos {
                    let (__ch, __next) = char_range_at(__input, __pos);
                    match __ch {
                        '0'...'9' | '.' => Matched(__next, ()),
                        _ => __state.mark_failure(__pos, "[0-9.]"),
                    }
                } else {
                    __state.mark_failure(__pos, "[0-9.]")
                };
                __state.suppress_fail -= 1;
                match __assert_res {
                    Matched(_, __value) => Matched(__pos, __value),
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = __parse_numeric_constant(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, c) => Matched(__pos, { c }),
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = {
                    __state.suppress_fail += 1;
                    let __assert_res = if __input.len() > __pos {
                        let (__ch, __next) = char_range_at(__input, __pos);
                        match __ch {
                            '\'' | 'u' | 'U' | 'L' => Matched(__next, ()),
                            _ => __state.mark_failure(__pos, "['uUL]"),
                        }
                    } else {
                        __state.mark_failure(__pos, "['uUL]")
                    };
                    __state.suppress_fail -= 1;
                    match __assert_res {
                        Matched(_, __value) => Matched(__pos, __value),
                        Failed => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_character_constant(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, c) => Matched(__pos, { Constant::Character(c) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_numeric_constant<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Constant> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_float_constant(__input, __state, __pos, env);
            match __seq_res {
                Matched(__pos, c) => Matched(__pos, { Constant::Float(c) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = __parse_integer_constant(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, c) => Matched(__pos, { Constant::Integer(c) }),
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_integer_constant<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Integer> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_integer_number(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, n) => {
                let __seq_res = __parse_integer_suffix(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, suffix) => Matched(__pos, {
                        let (base, number) = n;
                        Integer { base: base, number: number.to_owned().into_boxed_str(), suffix: suffix }
                    }),
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_integer_number<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<(IntegerBase, &'input str)> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let str_start = __pos;
                match {
                    let __seq_res = if __input.len() > __pos {
                        let (__ch, __next) = char_range_at(__input, __pos);
                        match __ch {
                            '1'...'9' => Matched(__next, ()),
                            _ => __state.mark_failure(__pos, "[1-9]"),
                        }
                    } else {
                        __state.mark_failure(__pos, "[1-9]")
                    };
                    match __seq_res {
                        Matched(__pos, _) => {
                            let mut __repeat_pos = __pos;
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = __parse_dec(__input, __state, __pos, env);
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            Matched(__repeat_pos, ())
                        }
                        Failed => Failed,
                    }
                } {
                    Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, n) => Matched(__pos, { (IntegerBase::Decimal, n) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = __parse_ohx(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = {
                                let str_start = __pos;
                                match {
                                    let mut __repeat_pos = __pos;
                                    let mut __repeat_value = vec![];
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __step_res = __parse_hex(__input, __state, __pos, env);
                                        match __step_res {
                                            Matched(__newpos, __value) => {
                                                __repeat_pos = __newpos;
                                                __repeat_value.push(__value);
                                            }
                                            Failed => {
                                                break;
                                            }
                                        }
                                    }
                                    if __repeat_value.len() >= 1 {
                                        Matched(__repeat_pos, ())
                                    } else {
                                        Failed
                                    }
                                } {
                                    Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                                    Failed => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, n) => Matched(__pos, { (IntegerBase::Hexadecimal, n) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = slice_eq(__input, __state, __pos, "0");
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let str_start = __pos;
                                        match {
                                            let mut __repeat_pos = __pos;
                                            let mut __repeat_value = vec![];
                                            loop {
                                                let __pos = __repeat_pos;
                                                let __step_res = __parse_oct(__input, __state, __pos, env);
                                                match __step_res {
                                                    Matched(__newpos, __value) => {
                                                        __repeat_pos = __newpos;
                                                        __repeat_value.push(__value);
                                                    }
                                                    Failed => {
                                                        break;
                                                    }
                                                }
                                            }
                                            if __repeat_value.len() >= 1 {
                                                Matched(__repeat_pos, ())
                                            } else {
                                                Failed
                                            }
                                        } {
                                            Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, n) => Matched(__pos, { (IntegerBase::Octal, n) }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = {
                                    let __seq_res = {
                                        __state.suppress_fail += 1;
                                        let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                        __state.suppress_fail -= 1;
                                        match __assert_res {
                                            Matched(_, __value) => Matched(__pos, __value),
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = {
                                                let __seq_res = __parse_obb(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = {
                                                            let str_start = __pos;
                                                            match {
                                                                let mut __repeat_pos = __pos;
                                                                let mut __repeat_value = vec![];
                                                                loop {
                                                                    let __pos = __repeat_pos;
                                                                    let __step_res = __parse_bin(__input, __state, __pos, env);
                                                                    match __step_res {
                                                                        Matched(__newpos, __value) => {
                                                                            __repeat_pos = __newpos;
                                                                            __repeat_value.push(__value);
                                                                        }
                                                                        Failed => {
                                                                            break;
                                                                        }
                                                                    }
                                                                }
                                                                if __repeat_value.len() >= 1 {
                                                                    Matched(__repeat_pos, ())
                                                                } else {
                                                                    Failed
                                                                }
                                                            } {
                                                                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                                                                Failed => Failed,
                                                            }
                                                        };
                                                        match __seq_res {
                                                            Matched(__pos, n) => Matched(__pos, { (IntegerBase::Binary, n) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, e) => Matched(__pos, { e }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __seq_res = {
                                            let str_start = __pos;
                                            match slice_eq(__input, __state, __pos, "0") {
                                                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                                                Failed => Failed,
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, n) => Matched(__pos, { (IntegerBase::Decimal, n) }),
                                            Failed => Failed,
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_integer_suffix<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<IntegerSuffix> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            __state.suppress_fail += 1;
            let res = __parse_integer_suffix_inner(__input, __state, __pos, env);
            __state.suppress_fail -= 1;
            res
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                __state.mark_failure(__pos, "integer suffix");
                Failed
            }
        }
    }
}

fn __parse_integer_suffix_inner<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<IntegerSuffix> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let str_start = __pos;
            match {
                let mut __repeat_pos = __pos;
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = {
                        let __choice_res = if __input.len() > __pos {
                            let (__ch, __next) = char_range_at(__input, __pos);
                            match __ch {
                                'u' | 'U' | 'l' | 'L' => Matched(__next, ()),
                                _ => __state.mark_failure(__pos, "[uUlL]"),
                            }
                        } else {
                            __state.mark_failure(__pos, "[uUlL]")
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __seq_res = {
                                    __state.suppress_fail += 1;
                                    let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                    __state.suppress_fail -= 1;
                                    match __assert_res {
                                        Matched(_, __value) => Matched(__pos, __value),
                                        Failed => Failed,
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = if __input.len() > __pos {
                                            let (__ch, __next) = char_range_at(__input, __pos);
                                            match __ch {
                                                'i' | 'I' | 'j' | 'J' => Matched(__next, ()),
                                                _ => __state.mark_failure(__pos, "[iIjJ]"),
                                            }
                                        } else {
                                            __state.mark_failure(__pos, "[iIjJ]")
                                        };
                                        match __seq_res {
                                            Matched(__pos, e) => Matched(__pos, { e }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                    };
                    match __step_res {
                        Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                        }
                        Failed => {
                            break;
                        }
                    }
                }
                Matched(__repeat_pos, ())
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, s) => match { int_suffix(s) } {
                Ok(res) => Matched(__pos, res),
                Err(expected) => {
                    __state.mark_failure(__pos, expected);
                    Failed
                }
            },
            Failed => Failed,
        }
    }
}

fn __parse_float_constant<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Float> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_float_number(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, n) => {
                let __seq_res = __parse_float_suffix(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, suffix) => Matched(__pos, {
                        let (base, number) = n;
                        Float { base: base, number: number.to_string().into_boxed_str(), suffix: suffix }
                    }),
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_float_number<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<(FloatBase, &'input str)> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let str_start = __pos;
                match __parse_float_decimal(__input, __state, __pos, env) {
                    Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, n) => Matched(__pos, { (FloatBase::Decimal, n) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = __parse_ohx(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let str_start = __pos;
                            match __parse_float_hexadecimal(__input, __state, __pos, env) {
                                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, n) => Matched(__pos, { (FloatBase::Hexadecimal, n) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_float_decimal<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let mut __repeat_pos = __pos;
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = __parse_dec(__input, __state, __pos, env);
                    match __step_res {
                        Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                        }
                        Failed => {
                            break;
                        }
                    }
                }
                Matched(__repeat_pos, ())
            };
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = slice_eq(__input, __state, __pos, ".");
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = {
                                let mut __repeat_pos = __pos;
                                let mut __repeat_value = vec![];
                                loop {
                                    let __pos = __repeat_pos;
                                    let __step_res = __parse_dec(__input, __state, __pos, env);
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                            __repeat_value.push(__value);
                                        }
                                        Failed => {
                                            break;
                                        }
                                    }
                                }
                                if __repeat_value.len() >= 1 {
                                    Matched(__repeat_pos, ())
                                } else {
                                    Failed
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => match __parse_float_decimal_exp(__input, __state, __pos, env) {
                                    Matched(__newpos, _) => Matched(__newpos, ()),
                                    Failed => Matched(__pos, ()),
                                },
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = {
                        let mut __repeat_pos = __pos;
                        let mut __repeat_value = vec![];
                        loop {
                            let __pos = __repeat_pos;
                            let __step_res = __parse_dec(__input, __state, __pos, env);
                            match __step_res {
                                Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                    __repeat_value.push(__value);
                                }
                                Failed => {
                                    break;
                                }
                            }
                        }
                        if __repeat_value.len() >= 1 {
                            Matched(__repeat_pos, ())
                        } else {
                            Failed
                        }
                    };
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = slice_eq(__input, __state, __pos, ".");
                            match __seq_res {
                                Matched(__pos, _) => match __parse_float_decimal_exp(__input, __state, __pos, env) {
                                    Matched(__newpos, _) => Matched(__newpos, ()),
                                    Failed => Matched(__pos, ()),
                                },
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = __parse_dec(__input, __state, __pos, env);
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            if __repeat_value.len() >= 1 {
                                Matched(__repeat_pos, ())
                            } else {
                                Failed
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => __parse_float_decimal_exp(__input, __state, __pos, env),
                            Failed => Failed,
                        }
                    }
                }
            }
        }
    }
}

fn __parse_float_decimal_exp<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = if __input.len() > __pos {
            let (__ch, __next) = char_range_at(__input, __pos);
            match __ch {
                'e' | 'E' => Matched(__next, ()),
                _ => __state.mark_failure(__pos, "[eE]"),
            }
        } else {
            __state.mark_failure(__pos, "[eE]")
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = match if __input.len() > __pos {
                    let (__ch, __next) = char_range_at(__input, __pos);
                    match __ch {
                        '+' | '-' => Matched(__next, ()),
                        _ => __state.mark_failure(__pos, "[+-]"),
                    }
                } else {
                    __state.mark_failure(__pos, "[+-]")
                } {
                    Matched(__newpos, _) => Matched(__newpos, ()),
                    Failed => Matched(__pos, ()),
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let mut __repeat_pos = __pos;
                        let mut __repeat_value = vec![];
                        loop {
                            let __pos = __repeat_pos;
                            let __step_res = __parse_dec(__input, __state, __pos, env);
                            match __step_res {
                                Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                    __repeat_value.push(__value);
                                }
                                Failed => {
                                    break;
                                }
                            }
                        }
                        if __repeat_value.len() >= 1 {
                            Matched(__repeat_pos, ())
                        } else {
                            Failed
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_float_hexadecimal<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let mut __repeat_pos = __pos;
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = __parse_hex(__input, __state, __pos, env);
                    match __step_res {
                        Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                        }
                        Failed => {
                            break;
                        }
                    }
                }
                Matched(__repeat_pos, ())
            };
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = slice_eq(__input, __state, __pos, ".");
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = {
                                let mut __repeat_pos = __pos;
                                let mut __repeat_value = vec![];
                                loop {
                                    let __pos = __repeat_pos;
                                    let __step_res = __parse_hex(__input, __state, __pos, env);
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                            __repeat_value.push(__value);
                                        }
                                        Failed => {
                                            break;
                                        }
                                    }
                                }
                                if __repeat_value.len() >= 1 {
                                    Matched(__repeat_pos, ())
                                } else {
                                    Failed
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => __parse_float_binary_exp(__input, __state, __pos, env),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = {
                        let mut __repeat_pos = __pos;
                        let mut __repeat_value = vec![];
                        loop {
                            let __pos = __repeat_pos;
                            let __step_res = __parse_hex(__input, __state, __pos, env);
                            match __step_res {
                                Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                    __repeat_value.push(__value);
                                }
                                Failed => {
                                    break;
                                }
                            }
                        }
                        if __repeat_value.len() >= 1 {
                            Matched(__repeat_pos, ())
                        } else {
                            Failed
                        }
                    };
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = slice_eq(__input, __state, __pos, ".");
                            match __seq_res {
                                Matched(__pos, _) => __parse_float_binary_exp(__input, __state, __pos, env),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = __parse_hex(__input, __state, __pos, env);
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            if __repeat_value.len() >= 1 {
                                Matched(__repeat_pos, ())
                            } else {
                                Failed
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => __parse_float_binary_exp(__input, __state, __pos, env),
                            Failed => Failed,
                        }
                    }
                }
            }
        }
    }
}

fn __parse_float_binary_exp<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = if __input.len() > __pos {
            let (__ch, __next) = char_range_at(__input, __pos);
            match __ch {
                'p' | 'P' => Matched(__next, ()),
                _ => __state.mark_failure(__pos, "[pP]"),
            }
        } else {
            __state.mark_failure(__pos, "[pP]")
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = match if __input.len() > __pos {
                    let (__ch, __next) = char_range_at(__input, __pos);
                    match __ch {
                        '+' | '-' => Matched(__next, ()),
                        _ => __state.mark_failure(__pos, "[+-]"),
                    }
                } else {
                    __state.mark_failure(__pos, "[+-]")
                } {
                    Matched(__newpos, _) => Matched(__newpos, ()),
                    Failed => Matched(__pos, ()),
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let mut __repeat_pos = __pos;
                        let mut __repeat_value = vec![];
                        loop {
                            let __pos = __repeat_pos;
                            let __step_res = __parse_dec(__input, __state, __pos, env);
                            match __step_res {
                                Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                    __repeat_value.push(__value);
                                }
                                Failed => {
                                    break;
                                }
                            }
                        }
                        if __repeat_value.len() >= 1 {
                            Matched(__repeat_pos, ())
                        } else {
                            Failed
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_float_suffix<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<FloatSuffix> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            __state.suppress_fail += 1;
            let res = __parse_float_suffix_inner(__input, __state, __pos, env);
            __state.suppress_fail -= 1;
            res
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                __state.mark_failure(__pos, "float literal suffix");
                Failed
            }
        }
    }
}

fn __parse_float_suffix_inner<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<FloatSuffix> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let __seq_res = {
                    __state.suppress_fail += 1;
                    let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                    __state.suppress_fail -= 1;
                    match __assert_res {
                        Matched(_, __value) => Matched(__pos, __value),
                        Failed => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = if __input.len() > __pos {
                            let (__ch, __next) = char_range_at(__input, __pos);
                            match __ch {
                                'i' | 'I' | 'j' | 'J' => Matched(__next, ()),
                                _ => __state.mark_failure(__pos, "[iIjJ]"),
                            }
                        } else {
                            __state.mark_failure(__pos, "[iIjJ]")
                        };
                        match __seq_res {
                            Matched(__pos, e) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = __parse_float_format(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, fmt) => Matched(__pos, { FloatSuffix { format: fmt, imaginary: true } }),
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = __parse_float_format(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, fmt) => {
                        let __seq_res = match {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                __state.suppress_fail -= 1;
                                match __assert_res {
                                    Matched(_, __value) => Matched(__pos, __value),
                                    Failed => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = if __input.len() > __pos {
                                        let (__ch, __next) = char_range_at(__input, __pos);
                                        match __ch {
                                            'i' | 'I' | 'j' | 'J' => Matched(__next, ()),
                                            _ => __state.mark_failure(__pos, "[iIjJ]"),
                                        }
                                    } else {
                                        __state.mark_failure(__pos, "[iIjJ]")
                                    };
                                    match __seq_res {
                                        Matched(__pos, e) => Matched(__pos, { e }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                            Failed => Matched(__pos, None),
                        };
                        match __seq_res {
                            Matched(__pos, imag) => Matched(__pos, { FloatSuffix { format: fmt, imaginary: imag.is_some() } }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_float_format<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<FloatFormat> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_ts18661_float_suffix(__input, __state, __pos, env);
            match __seq_res {
                Matched(__pos, f) => Matched(__pos, { FloatFormat::TS18661Format(f) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = if __input.len() > __pos {
                        let (__ch, __next) = char_range_at(__input, __pos);
                        match __ch {
                            'f' | 'F' => Matched(__next, ()),
                            _ => __state.mark_failure(__pos, "[fF]"),
                        }
                    } else {
                        __state.mark_failure(__pos, "[fF]")
                    };
                    match __seq_res {
                        Matched(__pos, _) => Matched(__pos, { FloatFormat::Float }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    'l' | 'L' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[lL]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[lL]")
                            };
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { FloatFormat::LongDouble }),
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => Matched(__pos, { FloatFormat::Double }),
                        }
                    }
                }
            }
        }
    }
}

fn __parse_character_constant<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<String> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let str_start = __pos;
            match {
                let __seq_res = match if __input.len() > __pos {
                    let (__ch, __next) = char_range_at(__input, __pos);
                    match __ch {
                        'L' | 'u' | 'U' => Matched(__next, ()),
                        _ => __state.mark_failure(__pos, "[LuU]"),
                    }
                } else {
                    __state.mark_failure(__pos, "[LuU]")
                } {
                    Matched(__newpos, _) => Matched(__newpos, ()),
                    Failed => Matched(__pos, ()),
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "'");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = {
                                    let mut __repeat_pos = __pos;
                                    let mut __repeat_value = vec![];
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __step_res = __parse_character(__input, __state, __pos, env);
                                        match __step_res {
                                            Matched(__newpos, __value) => {
                                                __repeat_pos = __newpos;
                                                __repeat_value.push(__value);
                                            }
                                            Failed => {
                                                break;
                                            }
                                        }
                                    }
                                    if __repeat_value.len() >= 1 {
                                        Matched(__repeat_pos, ())
                                    } else {
                                        Failed
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, _) => slice_eq(__input, __state, __pos, "'"),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, c) => Matched(__pos, { String::from(c) }),
            Failed => Failed,
        }
    }
}

fn __parse_character<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = if __input.len() > __pos {
            let (__ch, __next) = char_range_at(__input, __pos);
            match __ch {
                '\'' | '\\' | '\n' => __state.mark_failure(__pos, "[^'\\\n]"),
                _ => Matched(__next, ()),
            }
        } else {
            __state.mark_failure(__pos, "[^'\\\n]")
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => __parse_escape_sequence(__input, __state, __pos, env),
        }
    }
}

fn __parse_escape_sequence<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "\\");
        match __seq_res {
            Matched(__pos, _) => {
                let __choice_res = if __input.len() > __pos {
                    let (__ch, __next) = char_range_at(__input, __pos);
                    match __ch {
                        '\'' | '"' | '?' | '\\' | 'a' | 'b' | 'c' | 'f' | 'n' | 'r' | 't' | 'v' => Matched(__next, ()),
                        _ => __state.mark_failure(__pos, "['\"?\\abcfnrtv]"),
                    }
                } else {
                    __state.mark_failure(__pos, "['\"?\\abcfnrtv]")
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                if __repeat_value.len() >= 3 {
                                    break;
                                }
                                let __step_res = __parse_oct(__input, __state, __pos, env);
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            if __repeat_value.len() >= 1 {
                                Matched(__repeat_pos, ())
                            } else {
                                Failed
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __seq_res = slice_eq(__input, __state, __pos, "x");
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let mut __repeat_pos = __pos;
                                        let mut __repeat_value = vec![];
                                        loop {
                                            let __pos = __repeat_pos;
                                            let __step_res = __parse_hex(__input, __state, __pos, env);
                                            match __step_res {
                                                Matched(__newpos, __value) => {
                                                    __repeat_pos = __newpos;
                                                    __repeat_value.push(__value);
                                                }
                                                Failed => {
                                                    break;
                                                }
                                            }
                                        }
                                        if __repeat_value.len() >= 1 {
                                            Matched(__repeat_pos, ())
                                        } else {
                                            Failed
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                    }
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_string_literal<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<Vec<String>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __pos = if __repeat_value.len() > 0 {
                                    let __sep_res = __parse__(__input, __state, __pos, env);
                                    match __sep_res {
                                        Matched(__newpos, _) => __newpos,
                                        Failed => break,
                                    }
                                } else {
                                    __pos
                                };
                                let __step_res = __parse_string_literal0(__input, __state, __pos, env);
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            if __repeat_value.len() >= 1 {
                                Matched(__repeat_pos, __repeat_value)
                            } else {
                                Failed
                            }
                        };
                        match __seq_res {
                            Matched(__pos, e) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    };
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, s) => Matched(__pos, { s }),
            Failed => Failed,
        }
    }
}

fn __parse_string_literal0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<String> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let str_start = __pos;
            match {
                let __seq_res = match __parse_encoding_prefix(__input, __state, __pos, env) {
                    Matched(__newpos, _) => Matched(__newpos, ()),
                    Failed => Matched(__pos, ()),
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "\"");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = {
                                    let mut __repeat_pos = __pos;
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __step_res = __parse_string_char(__input, __state, __pos, env);
                                        match __step_res {
                                            Matched(__newpos, __value) => {
                                                __repeat_pos = __newpos;
                                            }
                                            Failed => {
                                                break;
                                            }
                                        }
                                    }
                                    Matched(__repeat_pos, ())
                                };
                                match __seq_res {
                                    Matched(__pos, _) => slice_eq(__input, __state, __pos, "\""),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, s) => Matched(__pos, { String::from(s) }),
            Failed => Failed,
        }
    }
}

fn __parse_encoding_prefix<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = slice_eq(__input, __state, __pos, "u8");
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                if __input.len() > __pos {
                    let (__ch, __next) = char_range_at(__input, __pos);
                    match __ch {
                        'u' | 'U' | 'L' => Matched(__next, ()),
                        _ => __state.mark_failure(__pos, "[uUL]"),
                    }
                } else {
                    __state.mark_failure(__pos, "[uUL]")
                }
            }
        }
    }
}

fn __parse_string_char<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = if __input.len() > __pos {
            let (__ch, __next) = char_range_at(__input, __pos);
            match __ch {
                '"' | '\\' | '\n' => __state.mark_failure(__pos, "[^\"\\\n]"),
                _ => Matched(__next, ()),
            }
        } else {
            __state.mark_failure(__pos, "[^\"\\\n]")
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => __parse_escape_sequence(__input, __state, __pos, env),
        }
    }
}

fn __parse_primary_expression<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Box<Node<Expression<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_primary_expression0(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, e) => Matched(__pos, { Box::new(e) }),
            Failed => Failed,
        }
    }
}

fn __parse_primary_expression0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Expression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_identifier(__input, __state, __pos, env);
            match __seq_res {
                Matched(__pos, a) => Matched(__pos, { Expression::Identifier(Box::new(a)) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = {
                        let __seq_res = Matched(__pos, __pos);
                        match __seq_res {
                            Matched(__pos, l) => {
                                let __seq_res = __parse_constant(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, e) => {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    };
                    match __seq_res {
                        Matched(__pos, a) => Matched(__pos, { Expression::Constant(Box::new(a)) }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = __parse_string_literal(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, a) => Matched(__pos, { Expression::StringLiteral(Box::new(a)) }),
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = {
                                    let __seq_res = slice_eq(__input, __state, __pos, "(");
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = __parse_expression0(__input, __state, __pos, env);
                                                    match __seq_res {
                                                        Matched(__pos, a) => {
                                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                                            match __seq_res {
                                                                Matched(__pos, _) => {
                                                                    let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                                    match __seq_res {
                                                                        Matched(__pos, _) => Matched(__pos, { a }),
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __choice_res = {
                                            let __seq_res = {
                                                let __seq_res = Matched(__pos, __pos);
                                                match __seq_res {
                                                    Matched(__pos, l) => {
                                                        let __seq_res = __parse_generic_selection(__input, __state, __pos, env);
                                                        match __seq_res {
                                                            Matched(__pos, e) => {
                                                                let __seq_res = Matched(__pos, __pos);
                                                                match __seq_res {
                                                                    Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, a) => Matched(__pos, { Expression::GenericSelection(Box::new(a)) }),
                                                Failed => Failed,
                                            }
                                        };
                                        match __choice_res {
                                            Matched(__pos, __value) => Matched(__pos, __value),
                                            Failed => {
                                                let __seq_res = {
                                                    __state.suppress_fail += 1;
                                                    let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                                    __state.suppress_fail -= 1;
                                                    match __assert_res {
                                                        Matched(_, __value) => Matched(__pos, __value),
                                                        Failed => Failed,
                                                    }
                                                };
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = __parse_gnu_primary_expression(__input, __state, __pos, env);
                                                        match __seq_res {
                                                            Matched(__pos, e) => Matched(__pos, { e }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_generic_selection<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<GenericSelection<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let res = {
                let __seq_res = slice_eq(__input, __state, __pos, "_Generic");
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                            };
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Failed => Matched(__pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "(");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = __parse_assignment_expression(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, e) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = slice_eq(__input, __state, __pos, ",");
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, _) => {
                                                                        let __seq_res = {
                                                                            let __seq_res = {
                                                                                let mut __repeat_pos = __pos;
                                                                                let mut __repeat_value = vec![];
                                                                                loop {
                                                                                    let __pos = __repeat_pos;
                                                                                    let __pos = if __repeat_value.len() > 0 {
                                                                                        let __sep_res = {
                                                                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                            match __seq_res {
                                                                                                Matched(__pos, _) => {
                                                                                                    let __seq_res = slice_eq(__input, __state, __pos, ",");
                                                                                                    match __seq_res {
                                                                                                        Matched(__pos, _) => __parse__(__input, __state, __pos, env),
                                                                                                        Failed => Failed,
                                                                                                    }
                                                                                                }
                                                                                                Failed => Failed,
                                                                                            }
                                                                                        };
                                                                                        match __sep_res {
                                                                                            Matched(__newpos, _) => __newpos,
                                                                                            Failed => break,
                                                                                        }
                                                                                    } else {
                                                                                        __pos
                                                                                    };
                                                                                    let __step_res = {
                                                                                        let __seq_res = Matched(__pos, __pos);
                                                                                        match __seq_res {
                                                                                            Matched(__pos, l) => {
                                                                                                let __seq_res = __parse_generic_association(__input, __state, __pos, env);
                                                                                                match __seq_res {
                                                                                                    Matched(__pos, e) => {
                                                                                                        let __seq_res = Matched(__pos, __pos);
                                                                                                        match __seq_res {
                                                                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                                                            Failed => Failed,
                                                                                                        }
                                                                                                    }
                                                                                                    Failed => Failed,
                                                                                                }
                                                                                            }
                                                                                            Failed => Failed,
                                                                                        }
                                                                                    };
                                                                                    match __step_res {
                                                                                        Matched(__newpos, __value) => {
                                                                                            __repeat_pos = __newpos;
                                                                                            __repeat_value.push(__value);
                                                                                        }
                                                                                        Failed => {
                                                                                            break;
                                                                                        }
                                                                                    }
                                                                                }
                                                                                if __repeat_value.len() >= 1 {
                                                                                    Matched(__repeat_pos, __repeat_value)
                                                                                } else {
                                                                                    Failed
                                                                                }
                                                                            };
                                                                            match __seq_res {
                                                                                Matched(__pos, e) => Matched(__pos, { e }),
                                                                                Failed => Failed,
                                                                            }
                                                                        };
                                                                        match __seq_res {
                                                                            Matched(__pos, a) => {
                                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                match __seq_res {
                                                                                    Matched(__pos, _) => {
                                                                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                                                        match __seq_res {
                                                                                            Matched(__pos, _) => Matched(__pos, { GenericSelection { expression: e, associations: a } }),
                                                                                            Failed => Failed,
                                                                                        }
                                                                                    }
                                                                                    Failed => Failed,
                                                                                }
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_generic_association<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<GenericAssociation<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_type_name(__input, __state, __pos, env);
            match __seq_res {
                Matched(__pos, t) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = slice_eq(__input, __state, __pos, ":");
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = __parse_assignment_expression(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, e) => Matched(__pos, {
                                                    let span = Span::span(t.span.start, e.span.end);
                                                    GenericAssociation::Type(Node::new(GenericAssociationType { type_name: t, expression: e }, span))
                                                }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = {
                    __state.suppress_fail += 1;
                    let res = {
                        let __seq_res = slice_eq(__input, __state, __pos, "default");
                        match __seq_res {
                            Matched(__pos, e) => {
                                let __seq_res = {
                                    __state.suppress_fail += 1;
                                    let __assert_res = if __input.len() > __pos {
                                        let (__ch, __next) = char_range_at(__input, __pos);
                                        match __ch {
                                            '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                            _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                        }
                                    } else {
                                        __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                    };
                                    __state.suppress_fail -= 1;
                                    match __assert_res {
                                        Failed => Matched(__pos, ()),
                                        Matched(..) => Failed,
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, _) => Matched(__pos, { e }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    };
                    __state.suppress_fail -= 1;
                    res
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse__(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = slice_eq(__input, __state, __pos, ":");
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = __parse_assignment_expression(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, e) => Matched(__pos, { GenericAssociation::Default(e) }),
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_postfix_expression<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Box<Node<Expression<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_postfix_expression0(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, e) => Matched(__pos, { Box::new(e) }),
            Failed => Failed,
        }
    }
}

fn __parse_postfix_expression0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Expression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    if let Some(entry) = __state.postfix_expression0_cache.get(&__pos) {
        return entry.clone();
    }
    let __rule_result = {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_postfix_expression1(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, e) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let __seq_res = {
                                let mut __repeat_pos = __pos;
                                let mut __repeat_value = vec![];
                                loop {
                                    let __pos = __repeat_pos;
                                    let __pos = if __repeat_value.len() > 0 {
                                        let __sep_res = __parse__(__input, __state, __pos, env);
                                        match __sep_res {
                                            Matched(__newpos, _) => __newpos,
                                            Failed => break,
                                        }
                                    } else {
                                        __pos
                                    };
                                    let __step_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = __parse_postfix_expressionT(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                            __repeat_value.push(__value);
                                        }
                                        Failed => {
                                            break;
                                        }
                                    }
                                }
                                Matched(__repeat_pos, __repeat_value)
                            };
                            match __seq_res {
                                Matched(__pos, e) => Matched(__pos, { e }),
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, t) => Matched(__pos, { apply_ops(t, e).node }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    };
    __state.postfix_expression0_cache.insert(__pos, __rule_result.clone());
    __rule_result
}

fn __parse_postfix_expression1<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Expression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = __parse_compound_literal(__input, __state, __pos, env);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => __parse_primary_expression0(__input, __state, __pos, env),
        }
    }
}

fn __parse_postfix_expressionT<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Operation<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = __parse_index_operator(__input, __state, __pos, env);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = slice_eq(__input, __state, __pos, "(");
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = {
                                            let mut __repeat_pos = __pos;
                                            let mut __repeat_value = vec![];
                                            loop {
                                                let __pos = __repeat_pos;
                                                let __pos = if __repeat_value.len() > 0 {
                                                    let __sep_res = {
                                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = slice_eq(__input, __state, __pos, ",");
                                                                match __seq_res {
                                                                    Matched(__pos, _) => __parse__(__input, __state, __pos, env),
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    };
                                                    match __sep_res {
                                                        Matched(__newpos, _) => __newpos,
                                                        Failed => break,
                                                    }
                                                } else {
                                                    __pos
                                                };
                                                let __step_res = {
                                                    let __seq_res = Matched(__pos, __pos);
                                                    match __seq_res {
                                                        Matched(__pos, l) => {
                                                            let __seq_res = __parse_assignment_expression0(__input, __state, __pos, env);
                                                            match __seq_res {
                                                                Matched(__pos, e) => {
                                                                    let __seq_res = Matched(__pos, __pos);
                                                                    match __seq_res {
                                                                        Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                };
                                                match __step_res {
                                                    Matched(__newpos, __value) => {
                                                        __repeat_pos = __newpos;
                                                        __repeat_value.push(__value);
                                                    }
                                                    Failed => {
                                                        break;
                                                    }
                                                }
                                            }
                                            Matched(__repeat_pos, __repeat_value)
                                        };
                                        match __seq_res {
                                            Matched(__pos, e) => Matched(__pos, { e }),
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                    match __seq_res {
                                                        Matched(__pos, _) => Matched(__pos, { Operation::Call(e) }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = {
                                let __seq_res = Matched(__pos, __pos);
                                match __seq_res {
                                    Matched(__pos, l) => {
                                        let __seq_res = __parse_member_operator(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, e) => {
                                                let __seq_res = Matched(__pos, __pos);
                                                match __seq_res {
                                                    Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, o) => {
                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = __parse_identifier(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, i) => Matched(__pos, { Operation::Member(o, i) }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __seq_res = {
                                    let __seq_res = Matched(__pos, __pos);
                                    match __seq_res {
                                        Matched(__pos, l) => {
                                            let __seq_res = __parse_postfix_operator(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, e) => {
                                                    let __seq_res = Matched(__pos, __pos);
                                                    match __seq_res {
                                                        Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, o) => Matched(__pos, { Operation::Unary(o) }),
                                    Failed => Failed,
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_index_operator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Operation<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_index_operator0(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, i) => Matched(__pos, { Operation::Binary(Node::new(BinaryOperator::Index, i.span), i.node) }),
            Failed => Failed,
        }
    }
}

fn __parse_index_operator0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<Expression<T::Interned>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "[");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, l) => {
                                    let __seq_res = __parse_expression0(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = Matched(__pos, __pos);
                                            match __seq_res {
                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, e) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = slice_eq(__input, __state, __pos, "]");
                                        match __seq_res {
                                            Matched(__pos, _) => Matched(__pos, { e }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_member_operator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<MemberOperator> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, ".");
            match __seq_res {
                Matched(__pos, _) => Matched(__pos, { MemberOperator::Direct }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = slice_eq(__input, __state, __pos, "->");
                match __seq_res {
                    Matched(__pos, _) => Matched(__pos, { MemberOperator::Indirect }),
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_postfix_operator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<UnaryOperator> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, "++");
            match __seq_res {
                Matched(__pos, _) => Matched(__pos, { UnaryOperator::PostIncrement }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = slice_eq(__input, __state, __pos, "--");
                match __seq_res {
                    Matched(__pos, _) => Matched(__pos, { UnaryOperator::PostDecrement }),
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_compound_literal<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Expression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_compound_literal_inner(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, n) => Matched(__pos, { Expression::CompoundLiteral(Box::new(n)) }),
            Failed => Failed,
        }
    }
}

fn __parse_compound_literal_inner<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<CompoundLiteral<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "(");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_type_name(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, t) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = slice_eq(__input, __state, __pos, "{");
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, _) => {
                                                                        let __seq_res = {
                                                                            let __seq_res = {
                                                                                let mut __repeat_pos = __pos;
                                                                                let mut __repeat_value = vec![];
                                                                                loop {
                                                                                    let __pos = __repeat_pos;
                                                                                    let __pos = if __repeat_value.len() > 0 {
                                                                                        let __sep_res = {
                                                                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                            match __seq_res {
                                                                                                Matched(__pos, _) => {
                                                                                                    let __seq_res = slice_eq(__input, __state, __pos, ",");
                                                                                                    match __seq_res {
                                                                                                        Matched(__pos, _) => __parse__(__input, __state, __pos, env),
                                                                                                        Failed => Failed,
                                                                                                    }
                                                                                                }
                                                                                                Failed => Failed,
                                                                                            }
                                                                                        };
                                                                                        match __sep_res {
                                                                                            Matched(__newpos, _) => __newpos,
                                                                                            Failed => break,
                                                                                        }
                                                                                    } else {
                                                                                        __pos
                                                                                    };
                                                                                    let __step_res = {
                                                                                        let __seq_res = Matched(__pos, __pos);
                                                                                        match __seq_res {
                                                                                            Matched(__pos, l) => {
                                                                                                let __seq_res = __parse_initializer_list_item(__input, __state, __pos, env);
                                                                                                match __seq_res {
                                                                                                    Matched(__pos, e) => {
                                                                                                        let __seq_res = Matched(__pos, __pos);
                                                                                                        match __seq_res {
                                                                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                                                            Failed => Failed,
                                                                                                        }
                                                                                                    }
                                                                                                    Failed => Failed,
                                                                                                }
                                                                                            }
                                                                                            Failed => Failed,
                                                                                        }
                                                                                    };
                                                                                    match __step_res {
                                                                                        Matched(__newpos, __value) => {
                                                                                            __repeat_pos = __newpos;
                                                                                            __repeat_value.push(__value);
                                                                                        }
                                                                                        Failed => {
                                                                                            break;
                                                                                        }
                                                                                    }
                                                                                }
                                                                                if __repeat_value.len() >= 1 {
                                                                                    Matched(__repeat_pos, __repeat_value)
                                                                                } else {
                                                                                    Failed
                                                                                }
                                                                            };
                                                                            match __seq_res {
                                                                                Matched(__pos, e) => Matched(__pos, { e }),
                                                                                Failed => Failed,
                                                                            }
                                                                        };
                                                                        match __seq_res {
                                                                            Matched(__pos, i) => {
                                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                match __seq_res {
                                                                                    Matched(__pos, _) => {
                                                                                        let __seq_res = match slice_eq(__input, __state, __pos, ",") {
                                                                                            Matched(__newpos, _) => Matched(__newpos, ()),
                                                                                            Failed => Matched(__pos, ()),
                                                                                        };
                                                                                        match __seq_res {
                                                                                            Matched(__pos, _) => {
                                                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                                match __seq_res {
                                                                                                    Matched(__pos, _) => {
                                                                                                        let __seq_res = slice_eq(__input, __state, __pos, "}");
                                                                                                        match __seq_res {
                                                                                                            Matched(__pos, _) => Matched(__pos, { CompoundLiteral { type_name: t, initializer_list: i } }),
                                                                                                            Failed => Failed,
                                                                                                        }
                                                                                                    }
                                                                                                    Failed => Failed,
                                                                                                }
                                                                                            }
                                                                                            Failed => Failed,
                                                                                        }
                                                                                    }
                                                                                    Failed => Failed,
                                                                                }
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_unary_expression<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Box<Node<Expression<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_unary_expression0(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, e) => Matched(__pos, { Box::new(e) }),
            Failed => Failed,
        }
    }
}

fn __parse_unary_expression0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Expression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = __parse_postfix_expression0(__input, __state, __pos, env);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = __parse_unary_prefix(__input, __state, __pos, env);
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = __parse_unary_cast(__input, __state, __pos, env);
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = __parse_sizeof_expression(__input, __state, __pos, env);
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __choice_res = __parse_alignof_expression(__input, __state, __pos, env);
                                        match __choice_res {
                                            Matched(__pos, __value) => Matched(__pos, __value),
                                            Failed => {
                                                let __seq_res = {
                                                    let __seq_res = {
                                                        __state.suppress_fail += 1;
                                                        let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                                        __state.suppress_fail -= 1;
                                                        match __assert_res {
                                                            Matched(_, __value) => Matched(__pos, __value),
                                                            Failed => Failed,
                                                        }
                                                    };
                                                    match __seq_res {
                                                        Matched(__pos, _) => {
                                                            let __seq_res = {
                                                                __state.suppress_fail += 1;
                                                                let res = {
                                                                    let __seq_res = slice_eq(__input, __state, __pos, "__extension__");
                                                                    match __seq_res {
                                                                        Matched(__pos, e) => {
                                                                            let __seq_res = {
                                                                                __state.suppress_fail += 1;
                                                                                let __assert_res = if __input.len() > __pos {
                                                                                    let (__ch, __next) = char_range_at(__input, __pos);
                                                                                    match __ch {
                                                                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                                                    }
                                                                                } else {
                                                                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                                                };
                                                                                __state.suppress_fail -= 1;
                                                                                match __assert_res {
                                                                                    Failed => Matched(__pos, ()),
                                                                                    Matched(..) => Failed,
                                                                                }
                                                                            };
                                                                            match __seq_res {
                                                                                Matched(__pos, _) => Matched(__pos, { e }),
                                                                                Failed => Failed,
                                                                            }
                                                                        }
                                                                        Failed => Failed,
                                                                    }
                                                                };
                                                                __state.suppress_fail -= 1;
                                                                res
                                                            };
                                                            match __seq_res {
                                                                Matched(__pos, e) => Matched(__pos, { e }),
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                };
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = __parse_unary_expression0(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, e) => Matched(__pos, { e }),
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_unary_prefix<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Expression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_unary_prefix_inner(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, n) => Matched(__pos, { Expression::UnaryOperator(Box::new(n)) }),
            Failed => Failed,
        }
    }
}

fn __parse_unary_prefix_inner<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<UnaryOperatorExpression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_prefix_operator(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, op) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_unary_expression(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, e) => Matched(__pos, { UnaryOperatorExpression { operator: op, operand: e } }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_prefix_operator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<UnaryOperator> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, "++");
            match __seq_res {
                Matched(__pos, _) => Matched(__pos, { UnaryOperator::PreIncrement }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = slice_eq(__input, __state, __pos, "--");
                    match __seq_res {
                        Matched(__pos, _) => Matched(__pos, { UnaryOperator::PreDecrement }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let res = {
                                let __seq_res = slice_eq(__input, __state, __pos, "sizeof");
                                match __seq_res {
                                    Matched(__pos, e) => {
                                        let __seq_res = {
                                            __state.suppress_fail += 1;
                                            let __assert_res = if __input.len() > __pos {
                                                let (__ch, __next) = char_range_at(__input, __pos);
                                                match __ch {
                                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                }
                                            } else {
                                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                            };
                                            __state.suppress_fail -= 1;
                                            match __assert_res {
                                                Failed => Matched(__pos, ()),
                                                Matched(..) => Failed,
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, _) => Matched(__pos, { e }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            };
                            __state.suppress_fail -= 1;
                            res
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { UnaryOperator::SizeOf }),
                            Failed => Failed,
                        }
                    }
                }
            }
        }
    }
}

fn __parse_unary_cast<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Expression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_unary_cast_inner(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, n) => Matched(__pos, { Expression::UnaryOperator(Box::new(n)) }),
            Failed => Failed,
        }
    }
}

fn __parse_unary_cast_inner<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<UnaryOperatorExpression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_unary_operator(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, op) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_cast_expression(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, e) => Matched(__pos, { UnaryOperatorExpression { operator: op, operand: e } }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_unary_operator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<UnaryOperator> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, "&");
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = {
                        __state.suppress_fail += 1;
                        let __assert_res = slice_eq(__input, __state, __pos, "&");
                        __state.suppress_fail -= 1;
                        match __assert_res {
                            Failed => Matched(__pos, ()),
                            Matched(..) => Failed,
                        }
                    };
                    match __seq_res {
                        Matched(__pos, _) => Matched(__pos, { UnaryOperator::Address }),
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = slice_eq(__input, __state, __pos, "*");
                    match __seq_res {
                        Matched(__pos, _) => Matched(__pos, { UnaryOperator::Indirection }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = slice_eq(__input, __state, __pos, "+");
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { UnaryOperator::Plus }),
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = {
                                    let __seq_res = slice_eq(__input, __state, __pos, "-");
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, { UnaryOperator::Minus }),
                                        Failed => Failed,
                                    }
                                };
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __choice_res = {
                                            let __seq_res = slice_eq(__input, __state, __pos, "~");
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { UnaryOperator::Complement }),
                                                Failed => Failed,
                                            }
                                        };
                                        match __choice_res {
                                            Matched(__pos, __value) => Matched(__pos, __value),
                                            Failed => {
                                                let __seq_res = slice_eq(__input, __state, __pos, "!");
                                                match __seq_res {
                                                    Matched(__pos, _) => Matched(__pos, { UnaryOperator::Negate }),
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_sizeof_expression<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Expression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let res = {
                let __seq_res = slice_eq(__input, __state, __pos, "sizeof");
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                            };
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Failed => Matched(__pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "(");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = __parse_type_name(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, t) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                        match __seq_res {
                                                            Matched(__pos, _) => Matched(__pos, { Expression::SizeOf(Box::new(t)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_alignof_expression<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Expression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let res = {
                let __seq_res = {
                    let __choice_res = slice_eq(__input, __state, __pos, "_Alignof");
                    match __choice_res {
                        Matched(__pos, __value) => Matched(__pos, __value),
                        Failed => {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                __state.suppress_fail -= 1;
                                match __assert_res {
                                    Matched(_, __value) => Matched(__pos, __value),
                                    Failed => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = slice_eq(__input, __state, __pos, "__alignof");
                                        match __seq_res {
                                            Matched(__pos, _) => match slice_eq(__input, __state, __pos, "__") {
                                                Matched(__newpos, _) => Matched(__newpos, ()),
                                                Failed => Matched(__pos, ()),
                                            },
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, e) => Matched(__pos, { e }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    }
                };
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                            };
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Failed => Matched(__pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "(");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = __parse_type_name(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, t) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                        match __seq_res {
                                                            Matched(__pos, _) => Matched(__pos, { Expression::AlignOf(Box::new(t)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_cast_expression<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Box<Node<Expression<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_cast_expression0(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, e) => Matched(__pos, { Box::new(e) }),
            Failed => Failed,
        }
    }
}

fn __parse_cast_expression0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Expression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let __seq_res = Matched(__pos, __pos);
                match __seq_res {
                    Matched(__pos, l) => {
                        let __seq_res = __parse_cast_expression_inner(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, e) => {
                                let __seq_res = Matched(__pos, __pos);
                                match __seq_res {
                                    Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, c) => Matched(__pos, { Expression::Cast(Box::new(c)) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => __parse_unary_expression0(__input, __state, __pos, env),
        }
    }
}

fn __parse_cast_expression_inner<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<CastExpression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "(");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_type_name(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, t) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = __parse_cast_expression(__input, __state, __pos, env);
                                                        match __seq_res {
                                                            Matched(__pos, e) => Matched(__pos, { CastExpression { type_name: t, expression: e } }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_binary_expression<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Box<Node<Expression<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_binary_expression0(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, e) => Matched(__pos, { Box::new(e) }),
            Failed => Failed,
        }
    }
}

fn __parse_binary_expression0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<Expression<T::Interned>>> {
    #![allow(non_snake_case, unused)]
    {
        fn __infix_parse<'input, T: Interner>(__min_prec: i32, __input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<Expression<T::Interned>>> {
            if let Matched(__pos, mut __infix_result) = __parse_binary_operand(__input, __state, __pos, env) {
                let mut __repeat_pos = __pos;
                loop {
                    let __pos = __repeat_pos;
                    if 0i32 >= __min_prec {
                        if let Matched(__pos, o) = {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = slice_eq(__input, __state, __pos, "||");
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, n) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { n }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            if let Matched(__pos, y) = __infix_parse(1i32, __input, __state, __pos, env) {
                                let x = __infix_result;
                                __infix_result = { infix(o, BinaryOperator::LogicalOr, x, y) };
                                __repeat_pos = __pos;
                                continue;
                            }
                        }
                    }
                    if 1i32 >= __min_prec {
                        if let Matched(__pos, o) = {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = slice_eq(__input, __state, __pos, "&&");
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, n) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { n }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            if let Matched(__pos, y) = __infix_parse(2i32, __input, __state, __pos, env) {
                                let x = __infix_result;
                                __infix_result = { infix(o, BinaryOperator::LogicalAnd, x, y) };
                                __repeat_pos = __pos;
                                continue;
                            }
                        }
                    }
                    if 2i32 >= __min_prec {
                        if let Matched(__pos, o) = {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = slice_eq(__input, __state, __pos, "|");
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, n) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { n }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            if let Matched(__pos, y) = __infix_parse(3i32, __input, __state, __pos, env) {
                                let x = __infix_result;
                                __infix_result = { infix(o, BinaryOperator::BitwiseOr, x, y) };
                                __repeat_pos = __pos;
                                continue;
                            }
                        }
                    }
                    if 3i32 >= __min_prec {
                        if let Matched(__pos, o) = {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = slice_eq(__input, __state, __pos, "^");
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, n) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { n }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            if let Matched(__pos, y) = __infix_parse(4i32, __input, __state, __pos, env) {
                                let x = __infix_result;
                                __infix_result = { infix(o, BinaryOperator::BitwiseXor, x, y) };
                                __repeat_pos = __pos;
                                continue;
                            }
                        }
                    }
                    if 4i32 >= __min_prec {
                        if let Matched(__pos, o) = {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = {
                                                    let __seq_res = slice_eq(__input, __state, __pos, "&");
                                                    match __seq_res {
                                                        Matched(__pos, _) => {
                                                            __state.suppress_fail += 1;
                                                            let __assert_res = slice_eq(__input, __state, __pos, "&");
                                                            __state.suppress_fail -= 1;
                                                            match __assert_res {
                                                                Failed => Matched(__pos, ()),
                                                                Matched(..) => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                };
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, n) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { n }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            if let Matched(__pos, y) = __infix_parse(5i32, __input, __state, __pos, env) {
                                let x = __infix_result;
                                __infix_result = { infix(o, BinaryOperator::BitwiseAnd, x, y) };
                                __repeat_pos = __pos;
                                continue;
                            }
                        }
                    }
                    if 5i32 >= __min_prec {
                        if let Matched(__pos, o) = {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = slice_eq(__input, __state, __pos, "==");
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, n) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { n }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            if let Matched(__pos, y) = __infix_parse(6i32, __input, __state, __pos, env) {
                                let x = __infix_result;
                                __infix_result = { infix(o, BinaryOperator::Equals, x, y) };
                                __repeat_pos = __pos;
                                continue;
                            }
                        }
                        if let Matched(__pos, o) = {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = slice_eq(__input, __state, __pos, "!=");
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, n) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { n }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            if let Matched(__pos, y) = __infix_parse(6i32, __input, __state, __pos, env) {
                                let x = __infix_result;
                                __infix_result = { infix(o, BinaryOperator::NotEquals, x, y) };
                                __repeat_pos = __pos;
                                continue;
                            }
                        }
                    }
                    if 6i32 >= __min_prec {
                        if let Matched(__pos, o) = {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = slice_eq(__input, __state, __pos, "<");
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, n) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { n }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            if let Matched(__pos, y) = __infix_parse(7i32, __input, __state, __pos, env) {
                                let x = __infix_result;
                                __infix_result = { infix(o, BinaryOperator::Less, x, y) };
                                __repeat_pos = __pos;
                                continue;
                            }
                        }
                        if let Matched(__pos, o) = {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = slice_eq(__input, __state, __pos, ">");
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, n) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { n }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            if let Matched(__pos, y) = __infix_parse(7i32, __input, __state, __pos, env) {
                                let x = __infix_result;
                                __infix_result = { infix(o, BinaryOperator::Greater, x, y) };
                                __repeat_pos = __pos;
                                continue;
                            }
                        }
                        if let Matched(__pos, o) = {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = slice_eq(__input, __state, __pos, "<=");
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, n) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { n }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            if let Matched(__pos, y) = __infix_parse(7i32, __input, __state, __pos, env) {
                                let x = __infix_result;
                                __infix_result = { infix(o, BinaryOperator::LessOrEqual, x, y) };
                                __repeat_pos = __pos;
                                continue;
                            }
                        }
                        if let Matched(__pos, o) = {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = slice_eq(__input, __state, __pos, ">=");
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, n) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { n }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            if let Matched(__pos, y) = __infix_parse(7i32, __input, __state, __pos, env) {
                                let x = __infix_result;
                                __infix_result = { infix(o, BinaryOperator::GreaterOrEqual, x, y) };
                                __repeat_pos = __pos;
                                continue;
                            }
                        }
                    }
                    if 7i32 >= __min_prec {
                        if let Matched(__pos, o) = {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = slice_eq(__input, __state, __pos, "<<");
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, n) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { n }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            if let Matched(__pos, y) = __infix_parse(8i32, __input, __state, __pos, env) {
                                let x = __infix_result;
                                __infix_result = { infix(o, BinaryOperator::ShiftLeft, x, y) };
                                __repeat_pos = __pos;
                                continue;
                            }
                        }
                        if let Matched(__pos, o) = {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = slice_eq(__input, __state, __pos, ">>");
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, n) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { n }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            if let Matched(__pos, y) = __infix_parse(8i32, __input, __state, __pos, env) {
                                let x = __infix_result;
                                __infix_result = { infix(o, BinaryOperator::ShiftRight, x, y) };
                                __repeat_pos = __pos;
                                continue;
                            }
                        }
                    }
                    if 8i32 >= __min_prec {
                        if let Matched(__pos, o) = {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = slice_eq(__input, __state, __pos, "+");
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, n) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { n }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            if let Matched(__pos, y) = __infix_parse(9i32, __input, __state, __pos, env) {
                                let x = __infix_result;
                                __infix_result = { infix(o, BinaryOperator::Plus, x, y) };
                                __repeat_pos = __pos;
                                continue;
                            }
                        }
                        if let Matched(__pos, o) = {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = slice_eq(__input, __state, __pos, "-");
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, n) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { n }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            if let Matched(__pos, y) = __infix_parse(9i32, __input, __state, __pos, env) {
                                let x = __infix_result;
                                __infix_result = { infix(o, BinaryOperator::Minus, x, y) };
                                __repeat_pos = __pos;
                                continue;
                            }
                        }
                    }
                    if 9i32 >= __min_prec {
                        if let Matched(__pos, o) = {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = slice_eq(__input, __state, __pos, "*");
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, n) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { n }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            if let Matched(__pos, y) = __infix_parse(10i32, __input, __state, __pos, env) {
                                let x = __infix_result;
                                __infix_result = { infix(o, BinaryOperator::Multiply, x, y) };
                                __repeat_pos = __pos;
                                continue;
                            }
                        }
                        if let Matched(__pos, o) = {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = slice_eq(__input, __state, __pos, "/");
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, n) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { n }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            if let Matched(__pos, y) = __infix_parse(10i32, __input, __state, __pos, env) {
                                let x = __infix_result;
                                __infix_result = { infix(o, BinaryOperator::Divide, x, y) };
                                __repeat_pos = __pos;
                                continue;
                            }
                        }
                        if let Matched(__pos, o) = {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = slice_eq(__input, __state, __pos, "%");
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, n) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { n }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            if let Matched(__pos, y) = __infix_parse(10i32, __input, __state, __pos, env) {
                                let x = __infix_result;
                                __infix_result = { infix(o, BinaryOperator::Modulo, x, y) };
                                __repeat_pos = __pos;
                                continue;
                            }
                        }
                    }
                    break;
                }
                Matched(__repeat_pos, __infix_result)
            } else {
                Failed
            }
        }
        __infix_parse(0, __input, __state, __pos, env)
    }
}

fn __parse_binary_operand<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<Expression<T::Interned>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = Matched(__pos, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse_cast_expression0(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = Matched(__pos, __pos);
                        match __seq_res {
                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_conditional_expression<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Box<Node<Expression<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_conditional_expression0(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, e) => Matched(__pos, { Box::new(e) }),
            Failed => Failed,
        }
    }
}

fn __parse_conditional_expression0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Expression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_binary_expression0(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, a) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = match __parse_conditional_expressionT(__input, __state, __pos, env) {
                            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                            Failed => Matched(__pos, None),
                        };
                        match __seq_res {
                            Matched(__pos, t) => Matched(__pos, {
                                if let Some((b, c)) = t {
                                    let span = Span::span(a.span.start, c.span.end);
                                    Expression::Conditional(Box::new(Node::new(ConditionalExpression { condition: Box::new(a), then_expression: b, else_expression: c }, span)))
                                } else {
                                    a.node
                                }
                            }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_conditional_expressionT<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<(Box<Node<Expression<T::Interned>>>, Box<Node<Expression<T::Interned>>>)> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "?");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, l) => {
                                    let __seq_res = __parse_expression0(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = Matched(__pos, __pos);
                                            match __seq_res {
                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, a) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = slice_eq(__input, __state, __pos, ":");
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = {
                                                            let __seq_res = Matched(__pos, __pos);
                                                            match __seq_res {
                                                                Matched(__pos, l) => {
                                                                    let __seq_res = __parse_conditional_expression0(__input, __state, __pos, env);
                                                                    match __seq_res {
                                                                        Matched(__pos, e) => {
                                                                            let __seq_res = Matched(__pos, __pos);
                                                                            match __seq_res {
                                                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                                Failed => Failed,
                                                                            }
                                                                        }
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        };
                                                        match __seq_res {
                                                            Matched(__pos, b) => Matched(__pos, { (Box::new(a), Box::new(b)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_assignment_expression<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Box<Node<Expression<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_assignment_expression0(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, e) => Matched(__pos, { Box::new(e) }),
            Failed => Failed,
        }
    }
}

fn __parse_assignment_expression0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Expression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let __seq_res = Matched(__pos, __pos);
                match __seq_res {
                    Matched(__pos, l) => {
                        let __seq_res = __parse_assignment_expression_inner(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, e) => {
                                let __seq_res = Matched(__pos, __pos);
                                match __seq_res {
                                    Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, n) => Matched(__pos, { Expression::BinaryOperator(Box::new(n)) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => __parse_conditional_expression0(__input, __state, __pos, env),
        }
    }
}

fn __parse_assignment_expression_inner<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<BinaryOperatorExpression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_unary_expression(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, a) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, l) => {
                                    let __seq_res = __parse_assignment_operator(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = Matched(__pos, __pos);
                                            match __seq_res {
                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, op) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = __parse_assignment_expression(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, b) => Matched(__pos, { BinaryOperatorExpression { operator: op, lhs: a, rhs: b } }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_assignment_operator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<BinaryOperator> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, "=");
            match __seq_res {
                Matched(__pos, _) => Matched(__pos, { BinaryOperator::Assign }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = slice_eq(__input, __state, __pos, "*=");
                    match __seq_res {
                        Matched(__pos, _) => Matched(__pos, { BinaryOperator::AssignMultiply }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = slice_eq(__input, __state, __pos, "/=");
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { BinaryOperator::AssignDivide }),
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = {
                                    let __seq_res = slice_eq(__input, __state, __pos, "%=");
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, { BinaryOperator::AssignModulo }),
                                        Failed => Failed,
                                    }
                                };
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __choice_res = {
                                            let __seq_res = slice_eq(__input, __state, __pos, "+=");
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { BinaryOperator::AssignPlus }),
                                                Failed => Failed,
                                            }
                                        };
                                        match __choice_res {
                                            Matched(__pos, __value) => Matched(__pos, __value),
                                            Failed => {
                                                let __choice_res = {
                                                    let __seq_res = slice_eq(__input, __state, __pos, "-=");
                                                    match __seq_res {
                                                        Matched(__pos, _) => Matched(__pos, { BinaryOperator::AssignMinus }),
                                                        Failed => Failed,
                                                    }
                                                };
                                                match __choice_res {
                                                    Matched(__pos, __value) => Matched(__pos, __value),
                                                    Failed => {
                                                        let __choice_res = {
                                                            let __seq_res = slice_eq(__input, __state, __pos, "<<=");
                                                            match __seq_res {
                                                                Matched(__pos, _) => Matched(__pos, { BinaryOperator::AssignShiftLeft }),
                                                                Failed => Failed,
                                                            }
                                                        };
                                                        match __choice_res {
                                                            Matched(__pos, __value) => Matched(__pos, __value),
                                                            Failed => {
                                                                let __choice_res = {
                                                                    let __seq_res = slice_eq(__input, __state, __pos, ">>=");
                                                                    match __seq_res {
                                                                        Matched(__pos, _) => Matched(__pos, { BinaryOperator::AssignShiftRight }),
                                                                        Failed => Failed,
                                                                    }
                                                                };
                                                                match __choice_res {
                                                                    Matched(__pos, __value) => Matched(__pos, __value),
                                                                    Failed => {
                                                                        let __choice_res = {
                                                                            let __seq_res = slice_eq(__input, __state, __pos, "&=");
                                                                            match __seq_res {
                                                                                Matched(__pos, _) => Matched(__pos, { BinaryOperator::AssignBitwiseAnd }),
                                                                                Failed => Failed,
                                                                            }
                                                                        };
                                                                        match __choice_res {
                                                                            Matched(__pos, __value) => Matched(__pos, __value),
                                                                            Failed => {
                                                                                let __choice_res = {
                                                                                    let __seq_res = slice_eq(__input, __state, __pos, "^=");
                                                                                    match __seq_res {
                                                                                        Matched(__pos, _) => Matched(__pos, { BinaryOperator::AssignBitwiseXor }),
                                                                                        Failed => Failed,
                                                                                    }
                                                                                };
                                                                                match __choice_res {
                                                                                    Matched(__pos, __value) => Matched(__pos, __value),
                                                                                    Failed => {
                                                                                        let __seq_res = slice_eq(__input, __state, __pos, "|=");
                                                                                        match __seq_res {
                                                                                            Matched(__pos, _) => Matched(__pos, { BinaryOperator::AssignBitwiseOr }),
                                                                                            Failed => Failed,
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_expression<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Box<Node<Expression<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_expression0(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, e) => Matched(__pos, { Box::new(e) }),
            Failed => Failed,
        }
    }
}

fn __parse_expression0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Expression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_assignment_expression0(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, e) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let __seq_res = {
                                let mut __repeat_pos = __pos;
                                let mut __repeat_value = vec![];
                                loop {
                                    let __pos = __repeat_pos;
                                    let __pos = if __repeat_value.len() > 0 {
                                        let __sep_res = __parse__(__input, __state, __pos, env);
                                        match __sep_res {
                                            Matched(__newpos, _) => __newpos,
                                            Failed => break,
                                        }
                                    } else {
                                        __pos
                                    };
                                    let __step_res = __parse_expressionT(__input, __state, __pos, env);
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                            __repeat_value.push(__value);
                                        }
                                        Failed => {
                                            break;
                                        }
                                    }
                                }
                                Matched(__repeat_pos, __repeat_value)
                            };
                            match __seq_res {
                                Matched(__pos, e) => Matched(__pos, { e }),
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, t) => Matched(__pos, {
                                if t.len() > 0 {
                                    let mut t = t;
                                    t.insert(0, e);
                                    Expression::Comma(Box::new(t))
                                } else {
                                    e.node
                                }
                            }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_expressionT<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<Expression<T::Interned>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, ",");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, l) => {
                                    let __seq_res = __parse_assignment_expression0(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = Matched(__pos, __pos);
                                            match __seq_res {
                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, e) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_constant_expression<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Box<Node<Expression<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    __parse_conditional_expression(__input, __state, __pos, env)
}

fn __parse_constant_expression0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Expression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    __parse_conditional_expression0(__input, __state, __pos, env)
}

fn __parse_declaration<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<Declaration<T::Interned>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = Matched(__pos, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse_declaration0(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = Matched(__pos, __pos);
                        match __seq_res {
                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_declaration0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Declaration<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = match {
            let __seq_res = {
                __state.suppress_fail += 1;
                let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                __state.suppress_fail -= 1;
                match __assert_res {
                    Matched(_, __value) => Matched(__pos, __value),
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = {
                        __state.suppress_fail += 1;
                        let res = {
                            let __seq_res = slice_eq(__input, __state, __pos, "__extension__");
                            match __seq_res {
                                Matched(__pos, e) => {
                                    let __seq_res = {
                                        __state.suppress_fail += 1;
                                        let __assert_res = if __input.len() > __pos {
                                            let (__ch, __next) = char_range_at(__input, __pos);
                                            match __ch {
                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                            }
                                        } else {
                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                        };
                                        __state.suppress_fail -= 1;
                                        match __assert_res {
                                            Failed => Matched(__pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, { e }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        __state.suppress_fail -= 1;
                        res
                    };
                    match __seq_res {
                        Matched(__pos, e) => Matched(__pos, { e }),
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        } {
            Matched(__newpos, _) => Matched(__newpos, ()),
            Failed => Matched(__pos, ()),
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_declaration1(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, d) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = slice_eq(__input, __state, __pos, ";");
                                        match __seq_res {
                                            Matched(__pos, _) => Matched(__pos, { Declaration { specifiers: d.0, declarators: d.1 } }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_declaration1<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<(Vec<Node<DeclarationSpecifier<T::Interned>>>, Vec<Node<InitDeclarator<T::Interned>>>)> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_declaration_specifiers_unique(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, h) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_declaration2(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, t) => Matched(__pos, { (concat(h, t.0), t.1) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_declaration2<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<(Vec<Node<DeclarationSpecifier<T::Interned>>>, Vec<Node<InitDeclarator<T::Interned>>>)> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_declaration_typedef(__input, __state, __pos, env);
            match __seq_res {
                Matched(__pos, h) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = __parse_declaration_typedef_tail(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, t) => Matched(__pos, { (concat(h, t.0), t.1) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = __parse_declaration_unique_type(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, h) => {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = __parse_declaration_specifiers_unique(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, h) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = {
                                                            let __choice_res = {
                                                                let __seq_res = __parse_declaration_typedef(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, h) => {
                                                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                                                        match __seq_res {
                                                                            Matched(__pos, _) => {
                                                                                let __seq_res = {
                                                                                    let __seq_res = __parse_declaration_specifiers_unique(__input, __state, __pos, env);
                                                                                    match __seq_res {
                                                                                        Matched(__pos, s) => {
                                                                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                            match __seq_res {
                                                                                                Matched(__pos, _) => {
                                                                                                    let __seq_res = __parse_declaration_type_declarators(__input, __state, __pos, env);
                                                                                                    match __seq_res {
                                                                                                        Matched(__pos, d) => Matched(__pos, { (s, d) }),
                                                                                                        Failed => Failed,
                                                                                                    }
                                                                                                }
                                                                                                Failed => Failed,
                                                                                            }
                                                                                        }
                                                                                        Failed => Failed,
                                                                                    }
                                                                                };
                                                                                match __seq_res {
                                                                                    Matched(__pos, t) => Matched(__pos, { (concat(h, t.0), t.1) }),
                                                                                    Failed => Failed,
                                                                                }
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            };
                                                            match __choice_res {
                                                                Matched(__pos, __value) => Matched(__pos, __value),
                                                                Failed => {
                                                                    let __seq_res = __parse_declaration_init_declarators(__input, __state, __pos, env);
                                                                    match __seq_res {
                                                                        Matched(__pos, d) => Matched(__pos, { (Vec::new(), d) }),
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                            }
                                                        };
                                                        match __seq_res {
                                                            Matched(__pos, t) => Matched(__pos, { (concat(h, t.0), t.1) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, t) => Matched(__pos, { (concat(h, t.0), t.1) }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __seq_res = __parse_declaration_nonunique_type(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, h) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = {
                                            let __seq_res = __parse_declaration_specifiers_nonunique(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, h) => {
                                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                                    match __seq_res {
                                                        Matched(__pos, _) => {
                                                            let __seq_res = {
                                                                let __choice_res = {
                                                                    let __seq_res = __parse_declaration_typedef(__input, __state, __pos, env);
                                                                    match __seq_res {
                                                                        Matched(__pos, h) => {
                                                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                                                            match __seq_res {
                                                                                Matched(__pos, _) => {
                                                                                    let __seq_res = {
                                                                                        let __seq_res = __parse_declaration_specifiers_nonunique(__input, __state, __pos, env);
                                                                                        match __seq_res {
                                                                                            Matched(__pos, s) => {
                                                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                                match __seq_res {
                                                                                                    Matched(__pos, _) => {
                                                                                                        let __seq_res = __parse_declaration_type_declarators(__input, __state, __pos, env);
                                                                                                        match __seq_res {
                                                                                                            Matched(__pos, d) => Matched(__pos, { (s, d) }),
                                                                                                            Failed => Failed,
                                                                                                        }
                                                                                                    }
                                                                                                    Failed => Failed,
                                                                                                }
                                                                                            }
                                                                                            Failed => Failed,
                                                                                        }
                                                                                    };
                                                                                    match __seq_res {
                                                                                        Matched(__pos, t) => Matched(__pos, { (concat(h, t.0), t.1) }),
                                                                                        Failed => Failed,
                                                                                    }
                                                                                }
                                                                                Failed => Failed,
                                                                            }
                                                                        }
                                                                        Failed => Failed,
                                                                    }
                                                                };
                                                                match __choice_res {
                                                                    Matched(__pos, __value) => Matched(__pos, __value),
                                                                    Failed => {
                                                                        let __seq_res = __parse_declaration_init_declarators(__input, __state, __pos, env);
                                                                        match __seq_res {
                                                                            Matched(__pos, d) => Matched(__pos, { (Vec::new(), d) }),
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                }
                                                            };
                                                            match __seq_res {
                                                                Matched(__pos, t) => Matched(__pos, { (concat(h, t.0), t.1) }),
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, t) => Matched(__pos, { (concat(h, t.0), t.1) }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
            }
        }
    }
}

fn __parse_declaration_typedef_tail<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<(Vec<Node<DeclarationSpecifier<T::Interned>>>, Vec<Node<InitDeclarator<T::Interned>>>)> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_declaration_specifiers_unique(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, h) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_declaration_typedef_tail0(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, t) => Matched(__pos, { (concat(h, t.0), t.1) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_declaration_typedef_tail0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<(Vec<Node<DeclarationSpecifier<T::Interned>>>, Vec<Node<InitDeclarator<T::Interned>>>)> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_declaration_unique_type(__input, __state, __pos, env);
            match __seq_res {
                Matched(__pos, h) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = {
                                let __seq_res = __parse_declaration_specifiers_unique(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, s) => {
                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = __parse_declaration_type_declarators(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, d) => Matched(__pos, { (s, d) }),
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, t) => Matched(__pos, { (concat(h, t.0), t.1) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = __parse_declaration_nonunique_type(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, h) => {
                        let __seq_res = __parse__(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = {
                                    let __seq_res = __parse_declaration_specifiers_nonunique(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, s) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = __parse_declaration_type_declarators(__input, __state, __pos, env);
                                                    match __seq_res {
                                                        Matched(__pos, d) => Matched(__pos, { (s, d) }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, t) => Matched(__pos, { (concat(h, t.0), t.1) }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_declaration_unique_type<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Vec<Node<DeclarationSpecifier<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_declaration_specifier_unique_type0(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, n) => Matched(__pos, { vec![n] }),
            Failed => Failed,
        }
    }
}

fn __parse_declaration_nonunique_type<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Vec<Node<DeclarationSpecifier<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_declaration_specifier_nonunique_type0(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, n) => Matched(__pos, { vec![n] }),
            Failed => Failed,
        }
    }
}

fn __parse_declaration_specifiers<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Vec<Node<DeclarationSpecifier<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_declaration_specifiers_unique(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, s) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_declaration_specifiers_tail(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, t) => Matched(__pos, { concat(s, t) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_declaration_specifiers_tail<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Vec<Node<DeclarationSpecifier<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_declaration_unique_type(__input, __state, __pos, env);
            match __seq_res {
                Matched(__pos, t) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = __parse_declaration_specifiers_unique(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, s) => Matched(__pos, { concat(t, s) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = __parse_declaration_nonunique_type(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, t) => {
                        let __seq_res = __parse__(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse_declaration_specifiers_nonunique(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, s) => Matched(__pos, { concat(t, s) }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_declaration_specifiers_unique<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Vec<Node<DeclarationSpecifier<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let mut __repeat_pos = __pos;
            let mut __repeat_value = vec![];
            loop {
                let __pos = __repeat_pos;
                let __pos = if __repeat_value.len() > 0 {
                    let __sep_res = __parse__(__input, __state, __pos, env);
                    match __sep_res {
                        Matched(__newpos, _) => __newpos,
                        Failed => break,
                    }
                } else {
                    __pos
                };
                let __step_res = {
                    let __seq_res = Matched(__pos, __pos);
                    match __seq_res {
                        Matched(__pos, l) => {
                            let __seq_res = __parse_declaration_specifier_nontype(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, e) => {
                                    let __seq_res = Matched(__pos, __pos);
                                    match __seq_res {
                                        Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __step_res {
                    Matched(__newpos, __value) => {
                        __repeat_pos = __newpos;
                        __repeat_value.push(__value);
                    }
                    Failed => {
                        break;
                    }
                }
            }
            Matched(__repeat_pos, __repeat_value)
        };
        match __seq_res {
            Matched(__pos, e) => Matched(__pos, { e }),
            Failed => Failed,
        }
    }
}

fn __parse_declaration_specifiers_nonunique<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Vec<Node<DeclarationSpecifier<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let mut __repeat_pos = __pos;
            let mut __repeat_value = vec![];
            loop {
                let __pos = __repeat_pos;
                let __pos = if __repeat_value.len() > 0 {
                    let __sep_res = __parse__(__input, __state, __pos, env);
                    match __sep_res {
                        Matched(__newpos, _) => __newpos,
                        Failed => break,
                    }
                } else {
                    __pos
                };
                let __step_res = {
                    let __seq_res = Matched(__pos, __pos);
                    match __seq_res {
                        Matched(__pos, l) => {
                            let __seq_res = {
                                let __choice_res = __parse_declaration_specifier_nontype(__input, __state, __pos, env);
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => __parse_declaration_specifier_nonunique_type0(__input, __state, __pos, env),
                                }
                            };
                            match __seq_res {
                                Matched(__pos, e) => {
                                    let __seq_res = Matched(__pos, __pos);
                                    match __seq_res {
                                        Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __step_res {
                    Matched(__newpos, __value) => {
                        __repeat_pos = __newpos;
                        __repeat_value.push(__value);
                    }
                    Failed => {
                        break;
                    }
                }
            }
            Matched(__repeat_pos, __repeat_value)
        };
        match __seq_res {
            Matched(__pos, e) => Matched(__pos, { e }),
            Failed => Failed,
        }
    }
}

fn __parse_declaration_specifier_nontype<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<DeclarationSpecifier<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_storage_class_specifier(__input, __state, __pos, env);
            match __seq_res {
                Matched(__pos, s) => Matched(__pos, { DeclarationSpecifier::StorageClass(s) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = __parse_type_qualifier(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, s) => Matched(__pos, { DeclarationSpecifier::TypeQualifier(s) }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = __parse_function_specifier(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, s) => Matched(__pos, { DeclarationSpecifier::Function(s) }),
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = {
                                    let __seq_res = __parse_alignment_specifier(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, s) => Matched(__pos, { DeclarationSpecifier::Alignment(s) }),
                                        Failed => Failed,
                                    }
                                };
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __seq_res = {
                                            let __seq_res = {
                                                __state.suppress_fail += 1;
                                                let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                                __state.suppress_fail -= 1;
                                                match __assert_res {
                                                    Matched(_, __value) => Matched(__pos, __value),
                                                    Failed => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = __parse_attribute_specifier(__input, __state, __pos, env);
                                                    match __seq_res {
                                                        Matched(__pos, e) => Matched(__pos, { e }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, s) => Matched(__pos, { DeclarationSpecifier::Extension(s) }),
                                            Failed => Failed,
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_declaration_typedef<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Vec<Node<DeclarationSpecifier<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_declaration_typedef0(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, s) => Matched(__pos, { vec![s] }),
            Failed => Failed,
        }
    }
}

fn __parse_declaration_typedef0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<DeclarationSpecifier<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_storage_class_typedef(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, s) => Matched(__pos, { DeclarationSpecifier::StorageClass(s) }),
            Failed => Failed,
        }
    }
}

fn __parse_declaration_specifier_unique_type0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<DeclarationSpecifier<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_type_specifier_unique(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, s) => Matched(__pos, { DeclarationSpecifier::TypeSpecifier(s) }),
            Failed => Failed,
        }
    }
}

fn __parse_declaration_specifier_nonunique_type0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<DeclarationSpecifier<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_type_specifier_nonunique(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, s) => Matched(__pos, { DeclarationSpecifier::TypeSpecifier(s) }),
            Failed => Failed,
        }
    }
}

fn __parse_declaration_init_declarators<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Vec<Node<InitDeclarator<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let mut __repeat_pos = __pos;
            let mut __repeat_value = vec![];
            loop {
                let __pos = __repeat_pos;
                let __pos = if __repeat_value.len() > 0 {
                    let __sep_res = {
                        let __seq_res = __parse__(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = slice_eq(__input, __state, __pos, ",");
                                match __seq_res {
                                    Matched(__pos, _) => __parse__(__input, __state, __pos, env),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    };
                    match __sep_res {
                        Matched(__newpos, _) => __newpos,
                        Failed => break,
                    }
                } else {
                    __pos
                };
                let __step_res = {
                    let __seq_res = Matched(__pos, __pos);
                    match __seq_res {
                        Matched(__pos, l) => {
                            let __seq_res = __parse_init_declarator(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, e) => {
                                    let __seq_res = Matched(__pos, __pos);
                                    match __seq_res {
                                        Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __step_res {
                    Matched(__newpos, __value) => {
                        __repeat_pos = __newpos;
                        __repeat_value.push(__value);
                    }
                    Failed => {
                        break;
                    }
                }
            }
            Matched(__repeat_pos, __repeat_value)
        };
        match __seq_res {
            Matched(__pos, e) => Matched(__pos, { e }),
            Failed => Failed,
        }
    }
}

fn __parse_declaration_type_declarators<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Vec<Node<InitDeclarator<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let mut __repeat_pos = __pos;
            let mut __repeat_value = vec![];
            loop {
                let __pos = __repeat_pos;
                let __pos = if __repeat_value.len() > 0 {
                    let __sep_res = {
                        let __seq_res = __parse__(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = slice_eq(__input, __state, __pos, ",");
                                match __seq_res {
                                    Matched(__pos, _) => __parse__(__input, __state, __pos, env),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    };
                    match __sep_res {
                        Matched(__newpos, _) => __newpos,
                        Failed => break,
                    }
                } else {
                    __pos
                };
                let __step_res = {
                    let __seq_res = Matched(__pos, __pos);
                    match __seq_res {
                        Matched(__pos, l) => {
                            let __seq_res = __parse_type_declarator(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, e) => {
                                    let __seq_res = Matched(__pos, __pos);
                                    match __seq_res {
                                        Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __step_res {
                    Matched(__newpos, __value) => {
                        __repeat_pos = __newpos;
                        __repeat_value.push(__value);
                    }
                    Failed => {
                        break;
                    }
                }
            }
            Matched(__repeat_pos, __repeat_value)
        };
        match __seq_res {
            Matched(__pos, e) => Matched(__pos, { e }),
            Failed => Failed,
        }
    }
}

fn __parse_init_declarator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<InitDeclarator<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_init_declarator_declarator(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, d) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = match {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                __state.suppress_fail -= 1;
                                match __assert_res {
                                    Matched(_, __value) => Matched(__pos, __value),
                                    Failed => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = __parse_init_declarator_gnu(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, e) => Matched(__pos, { e }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                            Failed => Matched(__pos, None),
                        };
                        match __seq_res {
                            Matched(__pos, e) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = match {
                                            let __seq_res = Matched(__pos, __pos);
                                            match __seq_res {
                                                Matched(__pos, l) => {
                                                    let __seq_res = __parse_init_declarator_init(__input, __state, __pos, env);
                                                    match __seq_res {
                                                        Matched(__pos, e) => {
                                                            let __seq_res = Matched(__pos, __pos);
                                                            match __seq_res {
                                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        } {
                                            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                            Failed => Matched(__pos, None),
                                        };
                                        match __seq_res {
                                            Matched(__pos, i) => Matched(__pos, { InitDeclarator { declarator: with_ext(d, e), initializer: i } }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_init_declarator_declarator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<Declarator<T::Interned>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_declarator(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, d) => Matched(__pos, {
                env.handle_declarator(&d, Symbol::Identifier);
                d
            }),
            Failed => Failed,
        }
    }
}

fn __parse_init_declarator_init<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Initializer<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "=");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_initializer(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, i) => Matched(__pos, { i }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_init_declarator_gnu<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Vec<Node<Extension<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = match __parse_asm_label(__input, __state, __pos, env) {
            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
            Failed => Matched(__pos, None),
        };
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_attribute_specifier_list(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, a) => Matched(__pos, { l.into_iter().chain(a).collect() }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_type_declarator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<InitDeclarator<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_declarator(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, d) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = match {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                __state.suppress_fail -= 1;
                                match __assert_res {
                                    Matched(_, __value) => Matched(__pos, __value),
                                    Failed => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = __parse_init_declarator_gnu(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, e) => Matched(__pos, { e }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                            Failed => Matched(__pos, None),
                        };
                        match __seq_res {
                            Matched(__pos, e) => Matched(__pos, {
                                env.handle_declarator(&d, Symbol::Typename);
                                InitDeclarator { declarator: with_ext(d, e), initializer: None }
                            }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_storage_class_specifier<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<StorageClassSpecifier>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = Matched(__pos, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse_storage_class_specifier0(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = Matched(__pos, __pos);
                        match __seq_res {
                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_storage_class_specifier0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<StorageClassSpecifier> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                __state.suppress_fail += 1;
                let res = {
                    let __seq_res = slice_eq(__input, __state, __pos, "extern");
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let __assert_res = if __input.len() > __pos {
                                    let (__ch, __next) = char_range_at(__input, __pos);
                                    match __ch {
                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                    }
                                } else {
                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                };
                                __state.suppress_fail -= 1;
                                match __assert_res {
                                    Failed => Matched(__pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { e }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                __state.suppress_fail -= 1;
                res
            };
            match __seq_res {
                Matched(__pos, _) => Matched(__pos, { StorageClassSpecifier::Extern }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = {
                        __state.suppress_fail += 1;
                        let res = {
                            let __seq_res = slice_eq(__input, __state, __pos, "static");
                            match __seq_res {
                                Matched(__pos, e) => {
                                    let __seq_res = {
                                        __state.suppress_fail += 1;
                                        let __assert_res = if __input.len() > __pos {
                                            let (__ch, __next) = char_range_at(__input, __pos);
                                            match __ch {
                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                            }
                                        } else {
                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                        };
                                        __state.suppress_fail -= 1;
                                        match __assert_res {
                                            Failed => Matched(__pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, { e }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        __state.suppress_fail -= 1;
                        res
                    };
                    match __seq_res {
                        Matched(__pos, _) => Matched(__pos, { StorageClassSpecifier::Static }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let res = {
                                    let __seq_res = slice_eq(__input, __state, __pos, "_Thread_local");
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = {
                                                __state.suppress_fail += 1;
                                                let __assert_res = if __input.len() > __pos {
                                                    let (__ch, __next) = char_range_at(__input, __pos);
                                                    match __ch {
                                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                    }
                                                } else {
                                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                };
                                                __state.suppress_fail -= 1;
                                                match __assert_res {
                                                    Failed => Matched(__pos, ()),
                                                    Matched(..) => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { e }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                __state.suppress_fail -= 1;
                                res
                            };
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { StorageClassSpecifier::ThreadLocal }),
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = {
                                    let __seq_res = {
                                        __state.suppress_fail += 1;
                                        let res = {
                                            let __seq_res = slice_eq(__input, __state, __pos, "auto");
                                            match __seq_res {
                                                Matched(__pos, e) => {
                                                    let __seq_res = {
                                                        __state.suppress_fail += 1;
                                                        let __assert_res = if __input.len() > __pos {
                                                            let (__ch, __next) = char_range_at(__input, __pos);
                                                            match __ch {
                                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                            }
                                                        } else {
                                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                        };
                                                        __state.suppress_fail -= 1;
                                                        match __assert_res {
                                                            Failed => Matched(__pos, ()),
                                                            Matched(..) => Failed,
                                                        }
                                                    };
                                                    match __seq_res {
                                                        Matched(__pos, _) => Matched(__pos, { e }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        };
                                        __state.suppress_fail -= 1;
                                        res
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, { StorageClassSpecifier::Auto }),
                                        Failed => Failed,
                                    }
                                };
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __seq_res = {
                                            __state.suppress_fail += 1;
                                            let res = {
                                                let __seq_res = slice_eq(__input, __state, __pos, "register");
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = {
                                                            __state.suppress_fail += 1;
                                                            let __assert_res = if __input.len() > __pos {
                                                                let (__ch, __next) = char_range_at(__input, __pos);
                                                                match __ch {
                                                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                                }
                                                            } else {
                                                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                            };
                                                            __state.suppress_fail -= 1;
                                                            match __assert_res {
                                                                Failed => Matched(__pos, ()),
                                                                Matched(..) => Failed,
                                                            }
                                                        };
                                                        match __seq_res {
                                                            Matched(__pos, _) => Matched(__pos, { e }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            };
                                            __state.suppress_fail -= 1;
                                            res
                                        };
                                        match __seq_res {
                                            Matched(__pos, _) => Matched(__pos, { StorageClassSpecifier::Register }),
                                            Failed => Failed,
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_storage_class_typedef<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<StorageClassSpecifier>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = Matched(__pos, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse_storage_class_typedef0(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = Matched(__pos, __pos);
                        match __seq_res {
                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_storage_class_typedef0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<StorageClassSpecifier> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let res = {
                let __seq_res = slice_eq(__input, __state, __pos, "typedef");
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                            };
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Failed => Matched(__pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __seq_res {
            Matched(__pos, _) => Matched(__pos, { StorageClassSpecifier::Typedef }),
            Failed => Failed,
        }
    }
}

fn __parse_type_specifier_unique<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<TypeSpecifier<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                __state.suppress_fail += 1;
                let res = {
                    let __seq_res = slice_eq(__input, __state, __pos, "void");
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let __assert_res = if __input.len() > __pos {
                                    let (__ch, __next) = char_range_at(__input, __pos);
                                    match __ch {
                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                    }
                                } else {
                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                };
                                __state.suppress_fail -= 1;
                                match __assert_res {
                                    Failed => Matched(__pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { e }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                __state.suppress_fail -= 1;
                res
            };
            match __seq_res {
                Matched(__pos, _) => Matched(__pos, { TypeSpecifier::Void }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = {
                        __state.suppress_fail += 1;
                        let res = {
                            let __seq_res = slice_eq(__input, __state, __pos, "_Bool");
                            match __seq_res {
                                Matched(__pos, e) => {
                                    let __seq_res = {
                                        __state.suppress_fail += 1;
                                        let __assert_res = if __input.len() > __pos {
                                            let (__ch, __next) = char_range_at(__input, __pos);
                                            match __ch {
                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                            }
                                        } else {
                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                        };
                                        __state.suppress_fail -= 1;
                                        match __assert_res {
                                            Failed => Matched(__pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, { e }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        __state.suppress_fail -= 1;
                        res
                    };
                    match __seq_res {
                        Matched(__pos, _) => Matched(__pos, { TypeSpecifier::Bool }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let res = {
                                    let __seq_res = slice_eq(__input, __state, __pos, "_Atomic");
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = {
                                                __state.suppress_fail += 1;
                                                let __assert_res = if __input.len() > __pos {
                                                    let (__ch, __next) = char_range_at(__input, __pos);
                                                    match __ch {
                                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                    }
                                                } else {
                                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                };
                                                __state.suppress_fail -= 1;
                                                match __assert_res {
                                                    Failed => Matched(__pos, ()),
                                                    Matched(..) => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { e }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                __state.suppress_fail -= 1;
                                res
                            };
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = slice_eq(__input, __state, __pos, "(");
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                                    match __seq_res {
                                                        Matched(__pos, _) => {
                                                            let __seq_res = __parse_type_name(__input, __state, __pos, env);
                                                            match __seq_res {
                                                                Matched(__pos, t) => {
                                                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                                                    match __seq_res {
                                                                        Matched(__pos, _) => {
                                                                            let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                                            match __seq_res {
                                                                                Matched(__pos, _) => Matched(__pos, { TypeSpecifier::Atomic(t) }),
                                                                                Failed => Failed,
                                                                            }
                                                                        }
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = __parse_struct_or_union_specifier(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, s) => Matched(__pos, { TypeSpecifier::Struct(s) }),
                                        Failed => Failed,
                                    }
                                };
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __choice_res = {
                                            let __seq_res = {
                                                let __seq_res = Matched(__pos, __pos);
                                                match __seq_res {
                                                    Matched(__pos, l) => {
                                                        let __seq_res = __parse_enum_specifier(__input, __state, __pos, env);
                                                        match __seq_res {
                                                            Matched(__pos, e) => {
                                                                let __seq_res = Matched(__pos, __pos);
                                                                match __seq_res {
                                                                    Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, e) => Matched(__pos, { TypeSpecifier::Enum(e) }),
                                                Failed => Failed,
                                            }
                                        };
                                        match __choice_res {
                                            Matched(__pos, __value) => Matched(__pos, __value),
                                            Failed => {
                                                let __seq_res = __parse_typedef_name(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, t) => Matched(__pos, { TypeSpecifier::TypedefName(t) }),
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_type_specifier_nonunique<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<TypeSpecifier<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                __state.suppress_fail += 1;
                let res = {
                    let __seq_res = slice_eq(__input, __state, __pos, "char");
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let __assert_res = if __input.len() > __pos {
                                    let (__ch, __next) = char_range_at(__input, __pos);
                                    match __ch {
                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                    }
                                } else {
                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                };
                                __state.suppress_fail -= 1;
                                match __assert_res {
                                    Failed => Matched(__pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { e }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                __state.suppress_fail -= 1;
                res
            };
            match __seq_res {
                Matched(__pos, _) => Matched(__pos, { TypeSpecifier::Char }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = {
                        __state.suppress_fail += 1;
                        let res = {
                            let __seq_res = slice_eq(__input, __state, __pos, "short");
                            match __seq_res {
                                Matched(__pos, e) => {
                                    let __seq_res = {
                                        __state.suppress_fail += 1;
                                        let __assert_res = if __input.len() > __pos {
                                            let (__ch, __next) = char_range_at(__input, __pos);
                                            match __ch {
                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                            }
                                        } else {
                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                        };
                                        __state.suppress_fail -= 1;
                                        match __assert_res {
                                            Failed => Matched(__pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, { e }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        __state.suppress_fail -= 1;
                        res
                    };
                    match __seq_res {
                        Matched(__pos, _) => Matched(__pos, { TypeSpecifier::Short }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let res = {
                                    let __seq_res = slice_eq(__input, __state, __pos, "int");
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = {
                                                __state.suppress_fail += 1;
                                                let __assert_res = if __input.len() > __pos {
                                                    let (__ch, __next) = char_range_at(__input, __pos);
                                                    match __ch {
                                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                    }
                                                } else {
                                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                };
                                                __state.suppress_fail -= 1;
                                                match __assert_res {
                                                    Failed => Matched(__pos, ()),
                                                    Matched(..) => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { e }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                __state.suppress_fail -= 1;
                                res
                            };
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { TypeSpecifier::Int }),
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = {
                                    let __seq_res = {
                                        __state.suppress_fail += 1;
                                        let res = {
                                            let __seq_res = slice_eq(__input, __state, __pos, "long");
                                            match __seq_res {
                                                Matched(__pos, e) => {
                                                    let __seq_res = {
                                                        __state.suppress_fail += 1;
                                                        let __assert_res = if __input.len() > __pos {
                                                            let (__ch, __next) = char_range_at(__input, __pos);
                                                            match __ch {
                                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                            }
                                                        } else {
                                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                        };
                                                        __state.suppress_fail -= 1;
                                                        match __assert_res {
                                                            Failed => Matched(__pos, ()),
                                                            Matched(..) => Failed,
                                                        }
                                                    };
                                                    match __seq_res {
                                                        Matched(__pos, _) => Matched(__pos, { e }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        };
                                        __state.suppress_fail -= 1;
                                        res
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, { TypeSpecifier::Long }),
                                        Failed => Failed,
                                    }
                                };
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __choice_res = {
                                            let __seq_res = {
                                                __state.suppress_fail += 1;
                                                let res = {
                                                    let __seq_res = slice_eq(__input, __state, __pos, "float");
                                                    match __seq_res {
                                                        Matched(__pos, e) => {
                                                            let __seq_res = {
                                                                __state.suppress_fail += 1;
                                                                let __assert_res = if __input.len() > __pos {
                                                                    let (__ch, __next) = char_range_at(__input, __pos);
                                                                    match __ch {
                                                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                                    }
                                                                } else {
                                                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                                };
                                                                __state.suppress_fail -= 1;
                                                                match __assert_res {
                                                                    Failed => Matched(__pos, ()),
                                                                    Matched(..) => Failed,
                                                                }
                                                            };
                                                            match __seq_res {
                                                                Matched(__pos, _) => Matched(__pos, { e }),
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                };
                                                __state.suppress_fail -= 1;
                                                res
                                            };
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { TypeSpecifier::Float }),
                                                Failed => Failed,
                                            }
                                        };
                                        match __choice_res {
                                            Matched(__pos, __value) => Matched(__pos, __value),
                                            Failed => {
                                                let __choice_res = {
                                                    let __seq_res = {
                                                        __state.suppress_fail += 1;
                                                        let res = {
                                                            let __seq_res = slice_eq(__input, __state, __pos, "double");
                                                            match __seq_res {
                                                                Matched(__pos, e) => {
                                                                    let __seq_res = {
                                                                        __state.suppress_fail += 1;
                                                                        let __assert_res = if __input.len() > __pos {
                                                                            let (__ch, __next) = char_range_at(__input, __pos);
                                                                            match __ch {
                                                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                                            }
                                                                        } else {
                                                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                                        };
                                                                        __state.suppress_fail -= 1;
                                                                        match __assert_res {
                                                                            Failed => Matched(__pos, ()),
                                                                            Matched(..) => Failed,
                                                                        }
                                                                    };
                                                                    match __seq_res {
                                                                        Matched(__pos, _) => Matched(__pos, { e }),
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        };
                                                        __state.suppress_fail -= 1;
                                                        res
                                                    };
                                                    match __seq_res {
                                                        Matched(__pos, _) => Matched(__pos, { TypeSpecifier::Double }),
                                                        Failed => Failed,
                                                    }
                                                };
                                                match __choice_res {
                                                    Matched(__pos, __value) => Matched(__pos, __value),
                                                    Failed => {
                                                        let __choice_res = {
                                                            let __seq_res = {
                                                                __state.suppress_fail += 1;
                                                                let res = {
                                                                    let __seq_res = {
                                                                        let __choice_res = slice_eq(__input, __state, __pos, "signed");
                                                                        match __choice_res {
                                                                            Matched(__pos, __value) => Matched(__pos, __value),
                                                                            Failed => {
                                                                                let __seq_res = {
                                                                                    __state.suppress_fail += 1;
                                                                                    let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                                                                    __state.suppress_fail -= 1;
                                                                                    match __assert_res {
                                                                                        Matched(_, __value) => Matched(__pos, __value),
                                                                                        Failed => Failed,
                                                                                    }
                                                                                };
                                                                                match __seq_res {
                                                                                    Matched(__pos, _) => {
                                                                                        let __seq_res = {
                                                                                            let __seq_res = slice_eq(__input, __state, __pos, "__signed");
                                                                                            match __seq_res {
                                                                                                Matched(__pos, _) => match slice_eq(__input, __state, __pos, "__") {
                                                                                                    Matched(__newpos, _) => Matched(__newpos, ()),
                                                                                                    Failed => Matched(__pos, ()),
                                                                                                },
                                                                                                Failed => Failed,
                                                                                            }
                                                                                        };
                                                                                        match __seq_res {
                                                                                            Matched(__pos, e) => Matched(__pos, { e }),
                                                                                            Failed => Failed,
                                                                                        }
                                                                                    }
                                                                                    Failed => Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                    };
                                                                    match __seq_res {
                                                                        Matched(__pos, e) => {
                                                                            let __seq_res = {
                                                                                __state.suppress_fail += 1;
                                                                                let __assert_res = if __input.len() > __pos {
                                                                                    let (__ch, __next) = char_range_at(__input, __pos);
                                                                                    match __ch {
                                                                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                                                    }
                                                                                } else {
                                                                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                                                };
                                                                                __state.suppress_fail -= 1;
                                                                                match __assert_res {
                                                                                    Failed => Matched(__pos, ()),
                                                                                    Matched(..) => Failed,
                                                                                }
                                                                            };
                                                                            match __seq_res {
                                                                                Matched(__pos, _) => Matched(__pos, { e }),
                                                                                Failed => Failed,
                                                                            }
                                                                        }
                                                                        Failed => Failed,
                                                                    }
                                                                };
                                                                __state.suppress_fail -= 1;
                                                                res
                                                            };
                                                            match __seq_res {
                                                                Matched(__pos, _) => Matched(__pos, { TypeSpecifier::Signed }),
                                                                Failed => Failed,
                                                            }
                                                        };
                                                        match __choice_res {
                                                            Matched(__pos, __value) => Matched(__pos, __value),
                                                            Failed => {
                                                                let __choice_res = {
                                                                    let __seq_res = {
                                                                        __state.suppress_fail += 1;
                                                                        let res = {
                                                                            let __seq_res = slice_eq(__input, __state, __pos, "unsigned");
                                                                            match __seq_res {
                                                                                Matched(__pos, e) => {
                                                                                    let __seq_res = {
                                                                                        __state.suppress_fail += 1;
                                                                                        let __assert_res = if __input.len() > __pos {
                                                                                            let (__ch, __next) = char_range_at(__input, __pos);
                                                                                            match __ch {
                                                                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                                                            }
                                                                                        } else {
                                                                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                                                        };
                                                                                        __state.suppress_fail -= 1;
                                                                                        match __assert_res {
                                                                                            Failed => Matched(__pos, ()),
                                                                                            Matched(..) => Failed,
                                                                                        }
                                                                                    };
                                                                                    match __seq_res {
                                                                                        Matched(__pos, _) => Matched(__pos, { e }),
                                                                                        Failed => Failed,
                                                                                    }
                                                                                }
                                                                                Failed => Failed,
                                                                            }
                                                                        };
                                                                        __state.suppress_fail -= 1;
                                                                        res
                                                                    };
                                                                    match __seq_res {
                                                                        Matched(__pos, _) => Matched(__pos, { TypeSpecifier::Unsigned }),
                                                                        Failed => Failed,
                                                                    }
                                                                };
                                                                match __choice_res {
                                                                    Matched(__pos, __value) => Matched(__pos, __value),
                                                                    Failed => {
                                                                        let __choice_res = {
                                                                            let __seq_res = {
                                                                                __state.suppress_fail += 1;
                                                                                let res = {
                                                                                    let __seq_res = {
                                                                                        let __choice_res = slice_eq(__input, __state, __pos, "_Complex");
                                                                                        match __choice_res {
                                                                                            Matched(__pos, __value) => Matched(__pos, __value),
                                                                                            Failed => {
                                                                                                let __seq_res = {
                                                                                                    __state.suppress_fail += 1;
                                                                                                    let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                                                                                    __state.suppress_fail -= 1;
                                                                                                    match __assert_res {
                                                                                                        Matched(_, __value) => Matched(__pos, __value),
                                                                                                        Failed => Failed,
                                                                                                    }
                                                                                                };
                                                                                                match __seq_res {
                                                                                                    Matched(__pos, _) => {
                                                                                                        let __seq_res = {
                                                                                                            let __seq_res = slice_eq(__input, __state, __pos, "__complex");
                                                                                                            match __seq_res {
                                                                                                                Matched(__pos, _) => match slice_eq(__input, __state, __pos, "__") {
                                                                                                                    Matched(__newpos, _) => Matched(__newpos, ()),
                                                                                                                    Failed => Matched(__pos, ()),
                                                                                                                },
                                                                                                                Failed => Failed,
                                                                                                            }
                                                                                                        };
                                                                                                        match __seq_res {
                                                                                                            Matched(__pos, e) => Matched(__pos, { e }),
                                                                                                            Failed => Failed,
                                                                                                        }
                                                                                                    }
                                                                                                    Failed => Failed,
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    };
                                                                                    match __seq_res {
                                                                                        Matched(__pos, e) => {
                                                                                            let __seq_res = {
                                                                                                __state.suppress_fail += 1;
                                                                                                let __assert_res = if __input.len() > __pos {
                                                                                                    let (__ch, __next) = char_range_at(__input, __pos);
                                                                                                    match __ch {
                                                                                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                                                                    }
                                                                                                } else {
                                                                                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                                                                };
                                                                                                __state.suppress_fail -= 1;
                                                                                                match __assert_res {
                                                                                                    Failed => Matched(__pos, ()),
                                                                                                    Matched(..) => Failed,
                                                                                                }
                                                                                            };
                                                                                            match __seq_res {
                                                                                                Matched(__pos, _) => Matched(__pos, { e }),
                                                                                                Failed => Failed,
                                                                                            }
                                                                                        }
                                                                                        Failed => Failed,
                                                                                    }
                                                                                };
                                                                                __state.suppress_fail -= 1;
                                                                                res
                                                                            };
                                                                            match __seq_res {
                                                                                Matched(__pos, _) => Matched(__pos, { TypeSpecifier::Complex }),
                                                                                Failed => Failed,
                                                                            }
                                                                        };
                                                                        match __choice_res {
                                                                            Matched(__pos, __value) => Matched(__pos, __value),
                                                                            Failed => {
                                                                                let __choice_res = {
                                                                                    let __seq_res = {
                                                                                        __state.suppress_fail += 1;
                                                                                        let res = {
                                                                                            let __seq_res = __parse_ts18661_float_type_specifier(__input, __state, __pos, env);
                                                                                            match __seq_res {
                                                                                                Matched(__pos, e) => {
                                                                                                    let __seq_res = {
                                                                                                        __state.suppress_fail += 1;
                                                                                                        let __assert_res = if __input.len() > __pos {
                                                                                                            let (__ch, __next) = char_range_at(__input, __pos);
                                                                                                            match __ch {
                                                                                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                                                                            }
                                                                                                        } else {
                                                                                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                                                                        };
                                                                                                        __state.suppress_fail -= 1;
                                                                                                        match __assert_res {
                                                                                                            Failed => Matched(__pos, ()),
                                                                                                            Matched(..) => Failed,
                                                                                                        }
                                                                                                    };
                                                                                                    match __seq_res {
                                                                                                        Matched(__pos, _) => Matched(__pos, { e }),
                                                                                                        Failed => Failed,
                                                                                                    }
                                                                                                }
                                                                                                Failed => Failed,
                                                                                            }
                                                                                        };
                                                                                        __state.suppress_fail -= 1;
                                                                                        res
                                                                                    };
                                                                                    match __seq_res {
                                                                                        Matched(__pos, t) => Matched(__pos, { TypeSpecifier::TS18661Float(t) }),
                                                                                        Failed => Failed,
                                                                                    }
                                                                                };
                                                                                match __choice_res {
                                                                                    Matched(__pos, __value) => Matched(__pos, __value),
                                                                                    Failed => {
                                                                                        let __seq_res = {
                                                                                            __state.suppress_fail += 1;
                                                                                            let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                                                                            __state.suppress_fail -= 1;
                                                                                            match __assert_res {
                                                                                                Matched(_, __value) => Matched(__pos, __value),
                                                                                                Failed => Failed,
                                                                                            }
                                                                                        };
                                                                                        match __seq_res {
                                                                                            Matched(__pos, _) => {
                                                                                                let __seq_res = __parse_typeof_specifier(__input, __state, __pos, env);
                                                                                                match __seq_res {
                                                                                                    Matched(__pos, e) => Matched(__pos, { e }),
                                                                                                    Failed => Failed,
                                                                                                }
                                                                                            }
                                                                                            Failed => Failed,
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_struct_or_union_specifier<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<StructType<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let __seq_res = Matched(__pos, __pos);
                match __seq_res {
                    Matched(__pos, l) => {
                        let __seq_res = __parse_struct_or_union(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, e) => {
                                let __seq_res = Matched(__pos, __pos);
                                match __seq_res {
                                    Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, t) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = match __parse_identifier(__input, __state, __pos, env) {
                                Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                Failed => Matched(__pos, None),
                            };
                            match __seq_res {
                                Matched(__pos, i) => {
                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = __parse_struct_or_union_body(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, d) => Matched(__pos, { StructType { kind: t, identifier: i, declarations: d } }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = {
                    let __seq_res = Matched(__pos, __pos);
                    match __seq_res {
                        Matched(__pos, l) => {
                            let __seq_res = __parse_struct_or_union(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, e) => {
                                    let __seq_res = Matched(__pos, __pos);
                                    match __seq_res {
                                        Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, t) => {
                        let __seq_res = __parse__(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse_identifier(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, i) => Matched(__pos, { StructType { kind: t, identifier: Some(i), declarations: None } }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_struct_or_union_body<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Option<Vec<Node<StructDeclaration<T::Interned>>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, "{");
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = {
                                let __seq_res = {
                                    let mut __repeat_pos = __pos;
                                    let mut __repeat_value = vec![];
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __pos = if __repeat_value.len() > 0 {
                                            let __sep_res = __parse__(__input, __state, __pos, env);
                                            match __sep_res {
                                                Matched(__newpos, _) => __newpos,
                                                Failed => break,
                                            }
                                        } else {
                                            __pos
                                        };
                                        let __step_res = {
                                            let __seq_res = Matched(__pos, __pos);
                                            match __seq_res {
                                                Matched(__pos, l) => {
                                                    let __seq_res = __parse_struct_declaration(__input, __state, __pos, env);
                                                    match __seq_res {
                                                        Matched(__pos, e) => {
                                                            let __seq_res = Matched(__pos, __pos);
                                                            match __seq_res {
                                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        };
                                        match __step_res {
                                            Matched(__newpos, __value) => {
                                                __repeat_pos = __newpos;
                                                __repeat_value.push(__value);
                                            }
                                            Failed => {
                                                break;
                                            }
                                        }
                                    }
                                    if __repeat_value.len() >= 1 {
                                        Matched(__repeat_pos, __repeat_value)
                                    } else {
                                        Failed
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, e) => Matched(__pos, { e }),
                                    Failed => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, d) => {
                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = slice_eq(__input, __state, __pos, "}");
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { Some(d) }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Matched(_, __value) => Matched(__pos, __value),
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = {
                                    let __seq_res = slice_eq(__input, __state, __pos, "{");
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => slice_eq(__input, __state, __pos, "}"),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, e) => Matched(__pos, { e }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    };
                    match __seq_res {
                        Matched(__pos, _) => Matched(__pos, { Some(Vec::new()) }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => Matched(__pos, { None }),
                }
            }
        }
    }
}

fn __parse_struct_or_union<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<StructKind> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                __state.suppress_fail += 1;
                let res = {
                    let __seq_res = slice_eq(__input, __state, __pos, "struct");
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let __assert_res = if __input.len() > __pos {
                                    let (__ch, __next) = char_range_at(__input, __pos);
                                    match __ch {
                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                    }
                                } else {
                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                };
                                __state.suppress_fail -= 1;
                                match __assert_res {
                                    Failed => Matched(__pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { e }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                __state.suppress_fail -= 1;
                res
            };
            match __seq_res {
                Matched(__pos, _) => Matched(__pos, { StructKind::Struct }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = {
                    __state.suppress_fail += 1;
                    let res = {
                        let __seq_res = slice_eq(__input, __state, __pos, "union");
                        match __seq_res {
                            Matched(__pos, e) => {
                                let __seq_res = {
                                    __state.suppress_fail += 1;
                                    let __assert_res = if __input.len() > __pos {
                                        let (__ch, __next) = char_range_at(__input, __pos);
                                        match __ch {
                                            '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                            _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                        }
                                    } else {
                                        __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                    };
                                    __state.suppress_fail -= 1;
                                    match __assert_res {
                                        Failed => Matched(__pos, ()),
                                        Matched(..) => Failed,
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, _) => Matched(__pos, { e }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    };
                    __state.suppress_fail -= 1;
                    res
                };
                match __seq_res {
                    Matched(__pos, _) => Matched(__pos, { StructKind::Union }),
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_struct_declaration<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<StructDeclaration<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let __seq_res = Matched(__pos, __pos);
                match __seq_res {
                    Matched(__pos, l) => {
                        let __seq_res = __parse_struct_field(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, e) => {
                                let __seq_res = Matched(__pos, __pos);
                                match __seq_res {
                                    Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, f) => Matched(__pos, { StructDeclaration::Field(f) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = __parse_static_assert(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, s) => Matched(__pos, { StructDeclaration::StaticAssert(s) }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __seq_res = {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                __state.suppress_fail -= 1;
                                match __assert_res {
                                    Matched(_, __value) => Matched(__pos, __value),
                                    Failed => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        __state.suppress_fail += 1;
                                        let res = {
                                            let __seq_res = slice_eq(__input, __state, __pos, "__extension__");
                                            match __seq_res {
                                                Matched(__pos, e) => {
                                                    let __seq_res = {
                                                        __state.suppress_fail += 1;
                                                        let __assert_res = if __input.len() > __pos {
                                                            let (__ch, __next) = char_range_at(__input, __pos);
                                                            match __ch {
                                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                            }
                                                        } else {
                                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                        };
                                                        __state.suppress_fail -= 1;
                                                        match __assert_res {
                                                            Failed => Matched(__pos, ()),
                                                            Matched(..) => Failed,
                                                        }
                                                    };
                                                    match __seq_res {
                                                        Matched(__pos, _) => Matched(__pos, { e }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        };
                                        __state.suppress_fail -= 1;
                                        res
                                    };
                                    match __seq_res {
                                        Matched(__pos, e) => Matched(__pos, { e }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = __parse_struct_declaration(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, d) => Matched(__pos, { d }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
            }
        }
    }
}

fn __parse_struct_field<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<StructField<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_specifier_qualifiers(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, s) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let __seq_res = {
                                let mut __repeat_pos = __pos;
                                let mut __repeat_value = vec![];
                                loop {
                                    let __pos = __repeat_pos;
                                    let __pos = if __repeat_value.len() > 0 {
                                        let __sep_res = {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = slice_eq(__input, __state, __pos, ",");
                                                    match __seq_res {
                                                        Matched(__pos, _) => __parse__(__input, __state, __pos, env),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        };
                                        match __sep_res {
                                            Matched(__newpos, _) => __newpos,
                                            Failed => break,
                                        }
                                    } else {
                                        __pos
                                    };
                                    let __step_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = __parse_struct_declarator(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                            __repeat_value.push(__value);
                                        }
                                        Failed => {
                                            break;
                                        }
                                    }
                                }
                                Matched(__repeat_pos, __repeat_value)
                            };
                            match __seq_res {
                                Matched(__pos, e) => Matched(__pos, { e }),
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, d) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = slice_eq(__input, __state, __pos, ";");
                                        match __seq_res {
                                            Matched(__pos, _) => Matched(__pos, { StructField { specifiers: s, declarators: d } }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_specifier_qualifiers<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Vec<Node<SpecifierQualifier<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let __seq_res = {
                    let mut __repeat_pos = __pos;
                    let mut __repeat_value = vec![];
                    loop {
                        let __pos = __repeat_pos;
                        let __pos = if __repeat_value.len() > 0 {
                            let __sep_res = __parse__(__input, __state, __pos, env);
                            match __sep_res {
                                Matched(__newpos, _) => __newpos,
                                Failed => break,
                            }
                        } else {
                            __pos
                        };
                        let __step_res = {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, l) => {
                                    let __seq_res = __parse_specifier_qualifier_qualifier0(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = Matched(__pos, __pos);
                                            match __seq_res {
                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __step_res {
                            Matched(__newpos, __value) => {
                                __repeat_pos = __newpos;
                                __repeat_value.push(__value);
                            }
                            Failed => {
                                break;
                            }
                        }
                    }
                    Matched(__repeat_pos, __repeat_value)
                };
                match __seq_res {
                    Matched(__pos, e) => Matched(__pos, { e }),
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, before) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = {
                                let __seq_res = Matched(__pos, __pos);
                                match __seq_res {
                                    Matched(__pos, l) => {
                                        let __seq_res = __parse_specifier_qualifier_unique_type0(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, e) => {
                                                let __seq_res = Matched(__pos, __pos);
                                                match __seq_res {
                                                    Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, single) => {
                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = {
                                                let __seq_res = {
                                                    let mut __repeat_pos = __pos;
                                                    let mut __repeat_value = vec![];
                                                    loop {
                                                        let __pos = __repeat_pos;
                                                        let __pos = if __repeat_value.len() > 0 {
                                                            let __sep_res = __parse__(__input, __state, __pos, env);
                                                            match __sep_res {
                                                                Matched(__newpos, _) => __newpos,
                                                                Failed => break,
                                                            }
                                                        } else {
                                                            __pos
                                                        };
                                                        let __step_res = {
                                                            let __seq_res = Matched(__pos, __pos);
                                                            match __seq_res {
                                                                Matched(__pos, l) => {
                                                                    let __seq_res = __parse_specifier_qualifier_qualifier0(__input, __state, __pos, env);
                                                                    match __seq_res {
                                                                        Matched(__pos, e) => {
                                                                            let __seq_res = Matched(__pos, __pos);
                                                                            match __seq_res {
                                                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                                Failed => Failed,
                                                                            }
                                                                        }
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        };
                                                        match __step_res {
                                                            Matched(__newpos, __value) => {
                                                                __repeat_pos = __newpos;
                                                                __repeat_value.push(__value);
                                                            }
                                                            Failed => {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    Matched(__repeat_pos, __repeat_value)
                                                };
                                                match __seq_res {
                                                    Matched(__pos, e) => Matched(__pos, { e }),
                                                    Failed => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, after) => Matched(__pos, {
                                                    let mut before = before;
                                                    before.push(single);
                                                    before.extend(after);
                                                    before
                                                }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = {
                    let __seq_res = {
                        let mut __repeat_pos = __pos;
                        let mut __repeat_value = vec![];
                        loop {
                            let __pos = __repeat_pos;
                            let __pos = if __repeat_value.len() > 0 {
                                let __sep_res = __parse__(__input, __state, __pos, env);
                                match __sep_res {
                                    Matched(__newpos, _) => __newpos,
                                    Failed => break,
                                }
                            } else {
                                __pos
                            };
                            let __step_res = {
                                let __seq_res = Matched(__pos, __pos);
                                match __seq_res {
                                    Matched(__pos, l) => {
                                        let __seq_res = __parse_specifier_qualifier_qualifier0(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, e) => {
                                                let __seq_res = Matched(__pos, __pos);
                                                match __seq_res {
                                                    Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            };
                            match __step_res {
                                Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                    __repeat_value.push(__value);
                                }
                                Failed => {
                                    break;
                                }
                            }
                        }
                        Matched(__repeat_pos, __repeat_value)
                    };
                    match __seq_res {
                        Matched(__pos, e) => Matched(__pos, { e }),
                        Failed => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, before) => {
                        let __seq_res = __parse__(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = {
                                    let __seq_res = Matched(__pos, __pos);
                                    match __seq_res {
                                        Matched(__pos, l) => {
                                            let __seq_res = __parse_specifier_qualifier_nonunique_type0(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, e) => {
                                                    let __seq_res = Matched(__pos, __pos);
                                                    match __seq_res {
                                                        Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, single) => {
                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = {
                                                    let __seq_res = {
                                                        let mut __repeat_pos = __pos;
                                                        let mut __repeat_value = vec![];
                                                        loop {
                                                            let __pos = __repeat_pos;
                                                            let __pos = if __repeat_value.len() > 0 {
                                                                let __sep_res = __parse__(__input, __state, __pos, env);
                                                                match __sep_res {
                                                                    Matched(__newpos, _) => __newpos,
                                                                    Failed => break,
                                                                }
                                                            } else {
                                                                __pos
                                                            };
                                                            let __step_res = {
                                                                let __choice_res = {
                                                                    let __seq_res = Matched(__pos, __pos);
                                                                    match __seq_res {
                                                                        Matched(__pos, l) => {
                                                                            let __seq_res = __parse_specifier_qualifier_nonunique_type0(__input, __state, __pos, env);
                                                                            match __seq_res {
                                                                                Matched(__pos, e) => {
                                                                                    let __seq_res = Matched(__pos, __pos);
                                                                                    match __seq_res {
                                                                                        Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                                        Failed => Failed,
                                                                                    }
                                                                                }
                                                                                Failed => Failed,
                                                                            }
                                                                        }
                                                                        Failed => Failed,
                                                                    }
                                                                };
                                                                match __choice_res {
                                                                    Matched(__pos, __value) => Matched(__pos, __value),
                                                                    Failed => {
                                                                        let __seq_res = Matched(__pos, __pos);
                                                                        match __seq_res {
                                                                            Matched(__pos, l) => {
                                                                                let __seq_res = __parse_specifier_qualifier_qualifier0(__input, __state, __pos, env);
                                                                                match __seq_res {
                                                                                    Matched(__pos, e) => {
                                                                                        let __seq_res = Matched(__pos, __pos);
                                                                                        match __seq_res {
                                                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                                            Failed => Failed,
                                                                                        }
                                                                                    }
                                                                                    Failed => Failed,
                                                                                }
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                }
                                                            };
                                                            match __step_res {
                                                                Matched(__newpos, __value) => {
                                                                    __repeat_pos = __newpos;
                                                                    __repeat_value.push(__value);
                                                                }
                                                                Failed => {
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                        Matched(__repeat_pos, __repeat_value)
                                                    };
                                                    match __seq_res {
                                                        Matched(__pos, e) => Matched(__pos, { e }),
                                                        Failed => Failed,
                                                    }
                                                };
                                                match __seq_res {
                                                    Matched(__pos, after) => Matched(__pos, {
                                                        let mut before = before;
                                                        before.push(single);
                                                        before.extend(after);
                                                        before
                                                    }),
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_specifier_qualifier_unique_type0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<SpecifierQualifier<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_type_specifier_unique(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, s) => Matched(__pos, { SpecifierQualifier::TypeSpecifier(s) }),
            Failed => Failed,
        }
    }
}

fn __parse_specifier_qualifier_nonunique_type0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<SpecifierQualifier<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_type_specifier_nonunique(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, s) => Matched(__pos, { SpecifierQualifier::TypeSpecifier(s) }),
            Failed => Failed,
        }
    }
}

fn __parse_specifier_qualifier_qualifier0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<SpecifierQualifier<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_type_qualifier(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, q) => Matched(__pos, { SpecifierQualifier::TypeQualifier(q) }),
            Failed => Failed,
        }
    }
}

fn __parse_struct_declarator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<StructDeclarator<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = match __parse_declarator(__input, __state, __pos, env) {
                Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                Failed => Matched(__pos, None),
            };
            match __seq_res {
                Matched(__pos, d) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = slice_eq(__input, __state, __pos, ":");
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = __parse_constant_expression(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, e) => {
                                                    let __seq_res = match {
                                                        let __seq_res = {
                                                            __state.suppress_fail += 1;
                                                            let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                                            __state.suppress_fail -= 1;
                                                            match __assert_res {
                                                                Matched(_, __value) => Matched(__pos, __value),
                                                                Failed => Failed,
                                                            }
                                                        };
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = __parse_attribute_specifier_list(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, e) => Matched(__pos, { e }),
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    } {
                                                        Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                                        Failed => Matched(__pos, None),
                                                    };
                                                    match __seq_res {
                                                        Matched(__pos, a) => Matched(__pos, { StructDeclarator { declarator: d.map(|d| with_ext(d, a)), bit_width: Some(e) } }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = __parse_declarator(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, d) => {
                        let __seq_res = __parse__(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = match {
                                    let __seq_res = {
                                        __state.suppress_fail += 1;
                                        let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                        __state.suppress_fail -= 1;
                                        match __assert_res {
                                            Matched(_, __value) => Matched(__pos, __value),
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = __parse_attribute_specifier_list(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, e) => Matched(__pos, { e }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                } {
                                    Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                    Failed => Matched(__pos, None),
                                };
                                match __seq_res {
                                    Matched(__pos, a) => Matched(__pos, { StructDeclarator { declarator: Some(with_ext(d, a)), bit_width: None } }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_enum_specifier<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<EnumType<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                __state.suppress_fail += 1;
                let res = {
                    let __seq_res = slice_eq(__input, __state, __pos, "enum");
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let __assert_res = if __input.len() > __pos {
                                    let (__ch, __next) = char_range_at(__input, __pos);
                                    match __ch {
                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                    }
                                } else {
                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                };
                                __state.suppress_fail -= 1;
                                match __assert_res {
                                    Failed => Matched(__pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { e }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                __state.suppress_fail -= 1;
                res
            };
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = match __parse_identifier(__input, __state, __pos, env) {
                                Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                Failed => Matched(__pos, None),
                            };
                            match __seq_res {
                                Matched(__pos, i) => {
                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = slice_eq(__input, __state, __pos, "{");
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                                    match __seq_res {
                                                        Matched(__pos, _) => {
                                                            let __seq_res = {
                                                                let __seq_res = {
                                                                    let mut __repeat_pos = __pos;
                                                                    let mut __repeat_value = vec![];
                                                                    loop {
                                                                        let __pos = __repeat_pos;
                                                                        let __pos = if __repeat_value.len() > 0 {
                                                                            let __sep_res = {
                                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                match __seq_res {
                                                                                    Matched(__pos, _) => {
                                                                                        let __seq_res = slice_eq(__input, __state, __pos, ",");
                                                                                        match __seq_res {
                                                                                            Matched(__pos, _) => __parse__(__input, __state, __pos, env),
                                                                                            Failed => Failed,
                                                                                        }
                                                                                    }
                                                                                    Failed => Failed,
                                                                                }
                                                                            };
                                                                            match __sep_res {
                                                                                Matched(__newpos, _) => __newpos,
                                                                                Failed => break,
                                                                            }
                                                                        } else {
                                                                            __pos
                                                                        };
                                                                        let __step_res = {
                                                                            let __seq_res = Matched(__pos, __pos);
                                                                            match __seq_res {
                                                                                Matched(__pos, l) => {
                                                                                    let __seq_res = __parse_enumerator(__input, __state, __pos, env);
                                                                                    match __seq_res {
                                                                                        Matched(__pos, e) => {
                                                                                            let __seq_res = Matched(__pos, __pos);
                                                                                            match __seq_res {
                                                                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                                                Failed => Failed,
                                                                                            }
                                                                                        }
                                                                                        Failed => Failed,
                                                                                    }
                                                                                }
                                                                                Failed => Failed,
                                                                            }
                                                                        };
                                                                        match __step_res {
                                                                            Matched(__newpos, __value) => {
                                                                                __repeat_pos = __newpos;
                                                                                __repeat_value.push(__value);
                                                                            }
                                                                            Failed => {
                                                                                break;
                                                                            }
                                                                        }
                                                                    }
                                                                    if __repeat_value.len() >= 1 {
                                                                        Matched(__repeat_pos, __repeat_value)
                                                                    } else {
                                                                        Failed
                                                                    }
                                                                };
                                                                match __seq_res {
                                                                    Matched(__pos, e) => Matched(__pos, { e }),
                                                                    Failed => Failed,
                                                                }
                                                            };
                                                            match __seq_res {
                                                                Matched(__pos, e) => {
                                                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                                                    match __seq_res {
                                                                        Matched(__pos, _) => {
                                                                            let __seq_res = match slice_eq(__input, __state, __pos, ",") {
                                                                                Matched(__newpos, _) => Matched(__newpos, ()),
                                                                                Failed => Matched(__pos, ()),
                                                                            };
                                                                            match __seq_res {
                                                                                Matched(__pos, _) => {
                                                                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                    match __seq_res {
                                                                                        Matched(__pos, _) => {
                                                                                            let __seq_res = slice_eq(__input, __state, __pos, "}");
                                                                                            match __seq_res {
                                                                                                Matched(__pos, _) => Matched(__pos, { EnumType { identifier: i, enumerators: e } }),
                                                                                                Failed => Failed,
                                                                                            }
                                                                                        }
                                                                                        Failed => Failed,
                                                                                    }
                                                                                }
                                                                                Failed => Failed,
                                                                            }
                                                                        }
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = {
                    __state.suppress_fail += 1;
                    let res = {
                        let __seq_res = slice_eq(__input, __state, __pos, "enum");
                        match __seq_res {
                            Matched(__pos, e) => {
                                let __seq_res = {
                                    __state.suppress_fail += 1;
                                    let __assert_res = if __input.len() > __pos {
                                        let (__ch, __next) = char_range_at(__input, __pos);
                                        match __ch {
                                            '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                            _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                        }
                                    } else {
                                        __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                    };
                                    __state.suppress_fail -= 1;
                                    match __assert_res {
                                        Failed => Matched(__pos, ()),
                                        Matched(..) => Failed,
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, _) => Matched(__pos, { e }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    };
                    __state.suppress_fail -= 1;
                    res
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse__(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse_identifier(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, i) => Matched(__pos, { EnumType { identifier: Some(i), enumerators: Vec::new() } }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_enumerator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Enumerator<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_identifier(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, i) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = match __parse_enumerator_constant(__input, __state, __pos, env) {
                            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                            Failed => Matched(__pos, None),
                        };
                        match __seq_res {
                            Matched(__pos, e) => Matched(__pos, {
                                env.add_interned_symbol(&i.node.name, Symbol::Identifier);
                                Enumerator { identifier: i, expression: e }
                            }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_enumerator_constant<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Box<Node<Expression<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "=");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_constant_expression(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, e) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_type_qualifier<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<TypeQualifier>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = Matched(__pos, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse_type_qualifier0(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = Matched(__pos, __pos);
                        match __seq_res {
                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_type_qualifier0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<TypeQualifier> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                __state.suppress_fail += 1;
                let res = {
                    let __seq_res = {
                        let __choice_res = slice_eq(__input, __state, __pos, "const");
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __seq_res = {
                                    __state.suppress_fail += 1;
                                    let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                    __state.suppress_fail -= 1;
                                    match __assert_res {
                                        Matched(_, __value) => Matched(__pos, __value),
                                        Failed => Failed,
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = slice_eq(__input, __state, __pos, "__const");
                                        match __seq_res {
                                            Matched(__pos, e) => Matched(__pos, { e }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                    };
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let __assert_res = if __input.len() > __pos {
                                    let (__ch, __next) = char_range_at(__input, __pos);
                                    match __ch {
                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                    }
                                } else {
                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                };
                                __state.suppress_fail -= 1;
                                match __assert_res {
                                    Failed => Matched(__pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { e }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                __state.suppress_fail -= 1;
                res
            };
            match __seq_res {
                Matched(__pos, _) => Matched(__pos, { TypeQualifier::Const }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = {
                        __state.suppress_fail += 1;
                        let res = {
                            let __seq_res = {
                                let __choice_res = slice_eq(__input, __state, __pos, "restrict");
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __seq_res = {
                                            __state.suppress_fail += 1;
                                            let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                            __state.suppress_fail -= 1;
                                            match __assert_res {
                                                Matched(_, __value) => Matched(__pos, __value),
                                                Failed => Failed,
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = {
                                                    let __seq_res = slice_eq(__input, __state, __pos, "__restrict");
                                                    match __seq_res {
                                                        Matched(__pos, _) => match slice_eq(__input, __state, __pos, "__") {
                                                            Matched(__newpos, _) => Matched(__newpos, ()),
                                                            Failed => Matched(__pos, ()),
                                                        },
                                                        Failed => Failed,
                                                    }
                                                };
                                                match __seq_res {
                                                    Matched(__pos, e) => Matched(__pos, { e }),
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                            };
                            match __seq_res {
                                Matched(__pos, e) => {
                                    let __seq_res = {
                                        __state.suppress_fail += 1;
                                        let __assert_res = if __input.len() > __pos {
                                            let (__ch, __next) = char_range_at(__input, __pos);
                                            match __ch {
                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                            }
                                        } else {
                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                        };
                                        __state.suppress_fail -= 1;
                                        match __assert_res {
                                            Failed => Matched(__pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, { e }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        __state.suppress_fail -= 1;
                        res
                    };
                    match __seq_res {
                        Matched(__pos, _) => Matched(__pos, { TypeQualifier::Restrict }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let res = {
                                    let __seq_res = {
                                        let __choice_res = slice_eq(__input, __state, __pos, "volatile");
                                        match __choice_res {
                                            Matched(__pos, __value) => Matched(__pos, __value),
                                            Failed => {
                                                let __seq_res = {
                                                    __state.suppress_fail += 1;
                                                    let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                                    __state.suppress_fail -= 1;
                                                    match __assert_res {
                                                        Matched(_, __value) => Matched(__pos, __value),
                                                        Failed => Failed,
                                                    }
                                                };
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = {
                                                            let __seq_res = slice_eq(__input, __state, __pos, "__volatile");
                                                            match __seq_res {
                                                                Matched(__pos, _) => match slice_eq(__input, __state, __pos, "__") {
                                                                    Matched(__newpos, _) => Matched(__newpos, ()),
                                                                    Failed => Matched(__pos, ()),
                                                                },
                                                                Failed => Failed,
                                                            }
                                                        };
                                                        match __seq_res {
                                                            Matched(__pos, e) => Matched(__pos, { e }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = {
                                                __state.suppress_fail += 1;
                                                let __assert_res = if __input.len() > __pos {
                                                    let (__ch, __next) = char_range_at(__input, __pos);
                                                    match __ch {
                                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                    }
                                                } else {
                                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                };
                                                __state.suppress_fail -= 1;
                                                match __assert_res {
                                                    Failed => Matched(__pos, ()),
                                                    Matched(..) => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { e }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                __state.suppress_fail -= 1;
                                res
                            };
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { TypeQualifier::Volatile }),
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = {
                                    let __seq_res = {
                                        let __seq_res = {
                                            __state.suppress_fail += 1;
                                            let __assert_res = __parse_clang_guard(__input, __state, __pos, env);
                                            __state.suppress_fail -= 1;
                                            match __assert_res {
                                                Matched(_, __value) => Matched(__pos, __value),
                                                Failed => Failed,
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = {
                                                    __state.suppress_fail += 1;
                                                    let res = {
                                                        let __seq_res = slice_eq(__input, __state, __pos, "_Nonnull");
                                                        match __seq_res {
                                                            Matched(__pos, e) => {
                                                                let __seq_res = {
                                                                    __state.suppress_fail += 1;
                                                                    let __assert_res = if __input.len() > __pos {
                                                                        let (__ch, __next) = char_range_at(__input, __pos);
                                                                        match __ch {
                                                                            '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                            _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                                        }
                                                                    } else {
                                                                        __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                                    };
                                                                    __state.suppress_fail -= 1;
                                                                    match __assert_res {
                                                                        Failed => Matched(__pos, ()),
                                                                        Matched(..) => Failed,
                                                                    }
                                                                };
                                                                match __seq_res {
                                                                    Matched(__pos, _) => Matched(__pos, { e }),
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    };
                                                    __state.suppress_fail -= 1;
                                                    res
                                                };
                                                match __seq_res {
                                                    Matched(__pos, e) => Matched(__pos, { e }),
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, { TypeQualifier::Nonnull }),
                                        Failed => Failed,
                                    }
                                };
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __choice_res = {
                                            let __seq_res = {
                                                let __seq_res = {
                                                    __state.suppress_fail += 1;
                                                    let __assert_res = __parse_clang_guard(__input, __state, __pos, env);
                                                    __state.suppress_fail -= 1;
                                                    match __assert_res {
                                                        Matched(_, __value) => Matched(__pos, __value),
                                                        Failed => Failed,
                                                    }
                                                };
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = {
                                                            __state.suppress_fail += 1;
                                                            let res = {
                                                                let __seq_res = slice_eq(__input, __state, __pos, "_Null_unspecified");
                                                                match __seq_res {
                                                                    Matched(__pos, e) => {
                                                                        let __seq_res = {
                                                                            __state.suppress_fail += 1;
                                                                            let __assert_res = if __input.len() > __pos {
                                                                                let (__ch, __next) = char_range_at(__input, __pos);
                                                                                match __ch {
                                                                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                                                }
                                                                            } else {
                                                                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                                            };
                                                                            __state.suppress_fail -= 1;
                                                                            match __assert_res {
                                                                                Failed => Matched(__pos, ()),
                                                                                Matched(..) => Failed,
                                                                            }
                                                                        };
                                                                        match __seq_res {
                                                                            Matched(__pos, _) => Matched(__pos, { e }),
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            };
                                                            __state.suppress_fail -= 1;
                                                            res
                                                        };
                                                        match __seq_res {
                                                            Matched(__pos, e) => Matched(__pos, { e }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { TypeQualifier::NullUnspecified }),
                                                Failed => Failed,
                                            }
                                        };
                                        match __choice_res {
                                            Matched(__pos, __value) => Matched(__pos, __value),
                                            Failed => {
                                                let __choice_res = {
                                                    let __seq_res = {
                                                        let __seq_res = {
                                                            __state.suppress_fail += 1;
                                                            let __assert_res = __parse_clang_guard(__input, __state, __pos, env);
                                                            __state.suppress_fail -= 1;
                                                            match __assert_res {
                                                                Matched(_, __value) => Matched(__pos, __value),
                                                                Failed => Failed,
                                                            }
                                                        };
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = {
                                                                    __state.suppress_fail += 1;
                                                                    let res = {
                                                                        let __seq_res = slice_eq(__input, __state, __pos, "_Nullable");
                                                                        match __seq_res {
                                                                            Matched(__pos, e) => {
                                                                                let __seq_res = {
                                                                                    __state.suppress_fail += 1;
                                                                                    let __assert_res = if __input.len() > __pos {
                                                                                        let (__ch, __next) = char_range_at(__input, __pos);
                                                                                        match __ch {
                                                                                            '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                                            _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                                                        }
                                                                                    } else {
                                                                                        __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                                                    };
                                                                                    __state.suppress_fail -= 1;
                                                                                    match __assert_res {
                                                                                        Failed => Matched(__pos, ()),
                                                                                        Matched(..) => Failed,
                                                                                    }
                                                                                };
                                                                                match __seq_res {
                                                                                    Matched(__pos, _) => Matched(__pos, { e }),
                                                                                    Failed => Failed,
                                                                                }
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    };
                                                                    __state.suppress_fail -= 1;
                                                                    res
                                                                };
                                                                match __seq_res {
                                                                    Matched(__pos, e) => Matched(__pos, { e }),
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    };
                                                    match __seq_res {
                                                        Matched(__pos, _) => Matched(__pos, { TypeQualifier::Nullable }),
                                                        Failed => Failed,
                                                    }
                                                };
                                                match __choice_res {
                                                    Matched(__pos, __value) => Matched(__pos, __value),
                                                    Failed => {
                                                        let __seq_res = {
                                                            __state.suppress_fail += 1;
                                                            let res = {
                                                                let __seq_res = slice_eq(__input, __state, __pos, "_Atomic");
                                                                match __seq_res {
                                                                    Matched(__pos, e) => {
                                                                        let __seq_res = {
                                                                            __state.suppress_fail += 1;
                                                                            let __assert_res = if __input.len() > __pos {
                                                                                let (__ch, __next) = char_range_at(__input, __pos);
                                                                                match __ch {
                                                                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                                                }
                                                                            } else {
                                                                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                                            };
                                                                            __state.suppress_fail -= 1;
                                                                            match __assert_res {
                                                                                Failed => Matched(__pos, ()),
                                                                                Matched(..) => Failed,
                                                                            }
                                                                        };
                                                                        match __seq_res {
                                                                            Matched(__pos, _) => Matched(__pos, { e }),
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            };
                                                            __state.suppress_fail -= 1;
                                                            res
                                                        };
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, _) => {
                                                                        let __seq_res = {
                                                                            __state.suppress_fail += 1;
                                                                            let __assert_res = slice_eq(__input, __state, __pos, "(");
                                                                            __state.suppress_fail -= 1;
                                                                            match __assert_res {
                                                                                Failed => Matched(__pos, ()),
                                                                                Matched(..) => Failed,
                                                                            }
                                                                        };
                                                                        match __seq_res {
                                                                            Matched(__pos, _) => Matched(__pos, { TypeQualifier::Atomic }),
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_function_specifier<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<FunctionSpecifier>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = Matched(__pos, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse_function_specifier0(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = Matched(__pos, __pos);
                        match __seq_res {
                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_function_specifier0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<FunctionSpecifier> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                __state.suppress_fail += 1;
                let res = {
                    let __seq_res = {
                        let __choice_res = slice_eq(__input, __state, __pos, "inline");
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __seq_res = {
                                    __state.suppress_fail += 1;
                                    let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                    __state.suppress_fail -= 1;
                                    match __assert_res {
                                        Matched(_, __value) => Matched(__pos, __value),
                                        Failed => Failed,
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = {
                                            let __seq_res = slice_eq(__input, __state, __pos, "__inline");
                                            match __seq_res {
                                                Matched(__pos, _) => match slice_eq(__input, __state, __pos, "__") {
                                                    Matched(__newpos, _) => Matched(__newpos, ()),
                                                    Failed => Matched(__pos, ()),
                                                },
                                                Failed => Failed,
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, e) => Matched(__pos, { e }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                    };
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let __assert_res = if __input.len() > __pos {
                                    let (__ch, __next) = char_range_at(__input, __pos);
                                    match __ch {
                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                    }
                                } else {
                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                };
                                __state.suppress_fail -= 1;
                                match __assert_res {
                                    Failed => Matched(__pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { e }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                __state.suppress_fail -= 1;
                res
            };
            match __seq_res {
                Matched(__pos, _) => Matched(__pos, { FunctionSpecifier::Inline }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = {
                    __state.suppress_fail += 1;
                    let res = {
                        let __seq_res = slice_eq(__input, __state, __pos, "_Noreturn");
                        match __seq_res {
                            Matched(__pos, e) => {
                                let __seq_res = {
                                    __state.suppress_fail += 1;
                                    let __assert_res = if __input.len() > __pos {
                                        let (__ch, __next) = char_range_at(__input, __pos);
                                        match __ch {
                                            '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                            _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                        }
                                    } else {
                                        __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                    };
                                    __state.suppress_fail -= 1;
                                    match __assert_res {
                                        Failed => Matched(__pos, ()),
                                        Matched(..) => Failed,
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, _) => Matched(__pos, { e }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    };
                    __state.suppress_fail -= 1;
                    res
                };
                match __seq_res {
                    Matched(__pos, _) => Matched(__pos, { FunctionSpecifier::Noreturn }),
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_alignment_specifier<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<AlignmentSpecifier<T::Interned>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = Matched(__pos, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse_alignment_specifier0(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = Matched(__pos, __pos);
                        match __seq_res {
                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_alignment_specifier0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<AlignmentSpecifier<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                __state.suppress_fail += 1;
                let res = {
                    let __seq_res = slice_eq(__input, __state, __pos, "_Alignas");
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let __assert_res = if __input.len() > __pos {
                                    let (__ch, __next) = char_range_at(__input, __pos);
                                    match __ch {
                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                    }
                                } else {
                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                };
                                __state.suppress_fail -= 1;
                                match __assert_res {
                                    Failed => Matched(__pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { e }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                __state.suppress_fail -= 1;
                res
            };
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = slice_eq(__input, __state, __pos, "(");
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = __parse_type_name(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, t) => {
                                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                                    match __seq_res {
                                                        Matched(__pos, _) => {
                                                            let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                            match __seq_res {
                                                                Matched(__pos, _) => Matched(__pos, { AlignmentSpecifier::Type(t) }),
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = {
                    __state.suppress_fail += 1;
                    let res = {
                        let __seq_res = slice_eq(__input, __state, __pos, "_Alignas");
                        match __seq_res {
                            Matched(__pos, e) => {
                                let __seq_res = {
                                    __state.suppress_fail += 1;
                                    let __assert_res = if __input.len() > __pos {
                                        let (__ch, __next) = char_range_at(__input, __pos);
                                        match __ch {
                                            '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                            _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                        }
                                    } else {
                                        __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                    };
                                    __state.suppress_fail -= 1;
                                    match __assert_res {
                                        Failed => Matched(__pos, ()),
                                        Matched(..) => Failed,
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, _) => Matched(__pos, { e }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    };
                    __state.suppress_fail -= 1;
                    res
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse__(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = slice_eq(__input, __state, __pos, "(");
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = __parse_constant_expression(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                                match __seq_res {
                                                                    Matched(__pos, _) => Matched(__pos, { AlignmentSpecifier::Constant(e) }),
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_declarator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<Declarator<T::Interned>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = Matched(__pos, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse_declarator0(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = Matched(__pos, __pos);
                        match __seq_res {
                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_declarator0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Declarator<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = match {
            let __seq_res = {
                __state.suppress_fail += 1;
                let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                __state.suppress_fail -= 1;
                match __assert_res {
                    Matched(_, __value) => Matched(__pos, __value),
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = __parse_attribute_specifier_list(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => Matched(__pos, { e }),
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        } {
            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
            Failed => Matched(__pos, None),
        };
        match __seq_res {
            Matched(__pos, attr) => {
                let __seq_res = {
                    let __seq_res = {
                        let mut __repeat_pos = __pos;
                        let mut __repeat_value = vec![];
                        loop {
                            let __pos = __repeat_pos;
                            let __pos = if __repeat_value.len() > 0 {
                                let __sep_res = __parse__(__input, __state, __pos, env);
                                match __sep_res {
                                    Matched(__newpos, _) => __newpos,
                                    Failed => break,
                                }
                            } else {
                                __pos
                            };
                            let __step_res = __parse_pointer(__input, __state, __pos, env);
                            match __step_res {
                                Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                    __repeat_value.push(__value);
                                }
                                Failed => {
                                    break;
                                }
                            }
                        }
                        Matched(__repeat_pos, __repeat_value)
                    };
                    match __seq_res {
                        Matched(__pos, e) => Matched(__pos, { e }),
                        Failed => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, pointer) => {
                        let __seq_res = __parse__(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = {
                                    let __seq_res = Matched(__pos, __pos);
                                    match __seq_res {
                                        Matched(__pos, l) => {
                                            let __seq_res = __parse_direct_declarator(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, e) => {
                                                    let __seq_res = Matched(__pos, __pos);
                                                    match __seq_res {
                                                        Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, kind) => {
                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = {
                                                    let __seq_res = {
                                                        let mut __repeat_pos = __pos;
                                                        let mut __repeat_value = vec![];
                                                        loop {
                                                            let __pos = __repeat_pos;
                                                            let __pos = if __repeat_value.len() > 0 {
                                                                let __sep_res = __parse__(__input, __state, __pos, env);
                                                                match __sep_res {
                                                                    Matched(__newpos, _) => __newpos,
                                                                    Failed => break,
                                                                }
                                                            } else {
                                                                __pos
                                                            };
                                                            let __step_res = {
                                                                let __seq_res = Matched(__pos, __pos);
                                                                match __seq_res {
                                                                    Matched(__pos, l) => {
                                                                        let __seq_res = __parse_derived_declarator(__input, __state, __pos, env);
                                                                        match __seq_res {
                                                                            Matched(__pos, e) => {
                                                                                let __seq_res = Matched(__pos, __pos);
                                                                                match __seq_res {
                                                                                    Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                                    Failed => Failed,
                                                                                }
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            };
                                                            match __step_res {
                                                                Matched(__newpos, __value) => {
                                                                    __repeat_pos = __newpos;
                                                                    __repeat_value.push(__value);
                                                                }
                                                                Failed => {
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                        Matched(__repeat_pos, __repeat_value)
                                                    };
                                                    match __seq_res {
                                                        Matched(__pos, e) => Matched(__pos, { e }),
                                                        Failed => Failed,
                                                    }
                                                };
                                                match __seq_res {
                                                    Matched(__pos, derived) => Matched(__pos, { Declarator { kind: kind, derived: concat(pointer, derived), extensions: attr.unwrap_or_default() } }),
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_direct_declarator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<DeclaratorKind<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_identifier(__input, __state, __pos, env);
            match __seq_res {
                Matched(__pos, i) => Matched(__pos, { DeclaratorKind::Identifier(i) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = slice_eq(__input, __state, __pos, "(");
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse__(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse_declarator(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, d) => {
                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                match __seq_res {
                                                    Matched(__pos, _) => Matched(__pos, { DeclaratorKind::Declarator(Box::new(d)) }),
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_derived_declarator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<DerivedDeclarator<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, "[");
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = {
                                let __seq_res = Matched(__pos, __pos);
                                match __seq_res {
                                    Matched(__pos, l) => {
                                        let __seq_res = __parse_array_declarator(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, e) => {
                                                let __seq_res = Matched(__pos, __pos);
                                                match __seq_res {
                                                    Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, a) => Matched(__pos, { DerivedDeclarator::Array(a) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = slice_eq(__input, __state, __pos, "(");
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, {
                                            env.enter_scope();
                                        });
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = match {
                                                    let __seq_res = Matched(__pos, __pos);
                                                    match __seq_res {
                                                        Matched(__pos, l) => {
                                                            let __seq_res = __parse_function_declarator(__input, __state, __pos, env);
                                                            match __seq_res {
                                                                Matched(__pos, e) => {
                                                                    let __seq_res = Matched(__pos, __pos);
                                                                    match __seq_res {
                                                                        Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                } {
                                                    Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                                    Failed => Matched(__pos, None),
                                                };
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        match {
                                                            env.leave_scope();
                                                            e.ok_or("")
                                                        } {
                                                            Ok(res) => Matched(__pos, res),
                                                            Err(expected) => {
                                                                __state.mark_failure(__pos, expected);
                                                                Failed
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, f) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                    match __seq_res {
                                                        Matched(__pos, _) => Matched(__pos, { DerivedDeclarator::Function(f) }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __seq_res = slice_eq(__input, __state, __pos, "(");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = {
                                            let __seq_res = {
                                                let mut __repeat_pos = __pos;
                                                let mut __repeat_value = vec![];
                                                loop {
                                                    let __pos = __repeat_pos;
                                                    let __pos = if __repeat_value.len() > 0 {
                                                        let __sep_res = {
                                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                                            match __seq_res {
                                                                Matched(__pos, _) => {
                                                                    let __seq_res = slice_eq(__input, __state, __pos, ",");
                                                                    match __seq_res {
                                                                        Matched(__pos, _) => __parse__(__input, __state, __pos, env),
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        };
                                                        match __sep_res {
                                                            Matched(__newpos, _) => __newpos,
                                                            Failed => break,
                                                        }
                                                    } else {
                                                        __pos
                                                    };
                                                    let __step_res = __parse_identifier(__input, __state, __pos, env);
                                                    match __step_res {
                                                        Matched(__newpos, __value) => {
                                                            __repeat_pos = __newpos;
                                                            __repeat_value.push(__value);
                                                        }
                                                        Failed => {
                                                            break;
                                                        }
                                                    }
                                                }
                                                Matched(__repeat_pos, __repeat_value)
                                            };
                                            match __seq_res {
                                                Matched(__pos, e) => Matched(__pos, { e }),
                                                Failed => Failed,
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, p) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                        match __seq_res {
                                                            Matched(__pos, _) => Matched(__pos, { DerivedDeclarator::KRFunction(p) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
            }
        }
    }
}

fn __parse_array_declarator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<ArrayDeclarator<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let __seq_res = {
                    let mut __repeat_pos = __pos;
                    let mut __repeat_value = vec![];
                    loop {
                        let __pos = __repeat_pos;
                        let __pos = if __repeat_value.len() > 0 {
                            let __sep_res = __parse__(__input, __state, __pos, env);
                            match __sep_res {
                                Matched(__newpos, _) => __newpos,
                                Failed => break,
                            }
                        } else {
                            __pos
                        };
                        let __step_res = __parse_type_qualifier(__input, __state, __pos, env);
                        match __step_res {
                            Matched(__newpos, __value) => {
                                __repeat_pos = __newpos;
                                __repeat_value.push(__value);
                            }
                            Failed => {
                                break;
                            }
                        }
                    }
                    Matched(__repeat_pos, __repeat_value)
                };
                match __seq_res {
                    Matched(__pos, e) => Matched(__pos, { e }),
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, q) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = slice_eq(__input, __state, __pos, "]");
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { ArrayDeclarator { qualifiers: q, size: ArraySize::Unknown } }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __pos = if __repeat_value.len() > 0 {
                                    let __sep_res = __parse__(__input, __state, __pos, env);
                                    match __sep_res {
                                        Matched(__newpos, _) => __newpos,
                                        Failed => break,
                                    }
                                } else {
                                    __pos
                                };
                                let __step_res = __parse_type_qualifier(__input, __state, __pos, env);
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            Matched(__repeat_pos, __repeat_value)
                        };
                        match __seq_res {
                            Matched(__pos, e) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    };
                    match __seq_res {
                        Matched(__pos, q) => {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = __parse_assignment_expression(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = slice_eq(__input, __state, __pos, "]");
                                                    match __seq_res {
                                                        Matched(__pos, _) => Matched(__pos, { ArrayDeclarator { qualifiers: q, size: ArraySize::VariableExpression(e) } }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let res = {
                                    let __seq_res = slice_eq(__input, __state, __pos, "static");
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = {
                                                __state.suppress_fail += 1;
                                                let __assert_res = if __input.len() > __pos {
                                                    let (__ch, __next) = char_range_at(__input, __pos);
                                                    match __ch {
                                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                    }
                                                } else {
                                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                };
                                                __state.suppress_fail -= 1;
                                                match __assert_res {
                                                    Failed => Matched(__pos, ()),
                                                    Matched(..) => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { e }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                __state.suppress_fail -= 1;
                                res
                            };
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = {
                                                let __seq_res = {
                                                    let mut __repeat_pos = __pos;
                                                    let mut __repeat_value = vec![];
                                                    loop {
                                                        let __pos = __repeat_pos;
                                                        let __pos = if __repeat_value.len() > 0 {
                                                            let __sep_res = __parse__(__input, __state, __pos, env);
                                                            match __sep_res {
                                                                Matched(__newpos, _) => __newpos,
                                                                Failed => break,
                                                            }
                                                        } else {
                                                            __pos
                                                        };
                                                        let __step_res = __parse_type_qualifier(__input, __state, __pos, env);
                                                        match __step_res {
                                                            Matched(__newpos, __value) => {
                                                                __repeat_pos = __newpos;
                                                                __repeat_value.push(__value);
                                                            }
                                                            Failed => {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    Matched(__repeat_pos, __repeat_value)
                                                };
                                                match __seq_res {
                                                    Matched(__pos, e) => Matched(__pos, { e }),
                                                    Failed => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, q) => {
                                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                                    match __seq_res {
                                                        Matched(__pos, _) => {
                                                            let __seq_res = __parse_assignment_expression(__input, __state, __pos, env);
                                                            match __seq_res {
                                                                Matched(__pos, e) => {
                                                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                                                    match __seq_res {
                                                                        Matched(__pos, _) => {
                                                                            let __seq_res = slice_eq(__input, __state, __pos, "]");
                                                                            match __seq_res {
                                                                                Matched(__pos, _) => Matched(__pos, { ArrayDeclarator { qualifiers: q, size: ArraySize::StaticExpression(e) } }),
                                                                                Failed => Failed,
                                                                            }
                                                                        }
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = {
                                    let __seq_res = {
                                        let __seq_res = {
                                            let mut __repeat_pos = __pos;
                                            let mut __repeat_value = vec![];
                                            loop {
                                                let __pos = __repeat_pos;
                                                let __pos = if __repeat_value.len() > 0 {
                                                    let __sep_res = __parse__(__input, __state, __pos, env);
                                                    match __sep_res {
                                                        Matched(__newpos, _) => __newpos,
                                                        Failed => break,
                                                    }
                                                } else {
                                                    __pos
                                                };
                                                let __step_res = __parse_type_qualifier(__input, __state, __pos, env);
                                                match __step_res {
                                                    Matched(__newpos, __value) => {
                                                        __repeat_pos = __newpos;
                                                        __repeat_value.push(__value);
                                                    }
                                                    Failed => {
                                                        break;
                                                    }
                                                }
                                            }
                                            if __repeat_value.len() >= 1 {
                                                Matched(__repeat_pos, __repeat_value)
                                            } else {
                                                Failed
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, e) => Matched(__pos, { e }),
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, q) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = {
                                                        __state.suppress_fail += 1;
                                                        let res = {
                                                            let __seq_res = slice_eq(__input, __state, __pos, "static");
                                                            match __seq_res {
                                                                Matched(__pos, e) => {
                                                                    let __seq_res = {
                                                                        __state.suppress_fail += 1;
                                                                        let __assert_res = if __input.len() > __pos {
                                                                            let (__ch, __next) = char_range_at(__input, __pos);
                                                                            match __ch {
                                                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                                            }
                                                                        } else {
                                                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                                        };
                                                                        __state.suppress_fail -= 1;
                                                                        match __assert_res {
                                                                            Failed => Matched(__pos, ()),
                                                                            Matched(..) => Failed,
                                                                        }
                                                                    };
                                                                    match __seq_res {
                                                                        Matched(__pos, _) => Matched(__pos, { e }),
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        };
                                                        __state.suppress_fail -= 1;
                                                        res
                                                    };
                                                    match __seq_res {
                                                        Matched(__pos, _) => {
                                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                                            match __seq_res {
                                                                Matched(__pos, _) => {
                                                                    let __seq_res = __parse_assignment_expression(__input, __state, __pos, env);
                                                                    match __seq_res {
                                                                        Matched(__pos, e) => {
                                                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                                                            match __seq_res {
                                                                                Matched(__pos, _) => {
                                                                                    let __seq_res = slice_eq(__input, __state, __pos, "]");
                                                                                    match __seq_res {
                                                                                        Matched(__pos, _) => Matched(__pos, { ArrayDeclarator { qualifiers: q, size: ArraySize::StaticExpression(e) } }),
                                                                                        Failed => Failed,
                                                                                    }
                                                                                }
                                                                                Failed => Failed,
                                                                            }
                                                                        }
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __seq_res = {
                                            let __seq_res = {
                                                let mut __repeat_pos = __pos;
                                                let mut __repeat_value = vec![];
                                                loop {
                                                    let __pos = __repeat_pos;
                                                    let __pos = if __repeat_value.len() > 0 {
                                                        let __sep_res = __parse__(__input, __state, __pos, env);
                                                        match __sep_res {
                                                            Matched(__newpos, _) => __newpos,
                                                            Failed => break,
                                                        }
                                                    } else {
                                                        __pos
                                                    };
                                                    let __step_res = __parse_type_qualifier(__input, __state, __pos, env);
                                                    match __step_res {
                                                        Matched(__newpos, __value) => {
                                                            __repeat_pos = __newpos;
                                                            __repeat_value.push(__value);
                                                        }
                                                        Failed => {
                                                            break;
                                                        }
                                                    }
                                                }
                                                Matched(__repeat_pos, __repeat_value)
                                            };
                                            match __seq_res {
                                                Matched(__pos, e) => Matched(__pos, { e }),
                                                Failed => Failed,
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, q) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = slice_eq(__input, __state, __pos, "*");
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, _) => {
                                                                        let __seq_res = slice_eq(__input, __state, __pos, "]");
                                                                        match __seq_res {
                                                                            Matched(__pos, _) => Matched(__pos, { ArrayDeclarator { qualifiers: q, size: ArraySize::VariableUnknown } }),
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_function_declarator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<FunctionDeclarator<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = {
                let mut __repeat_pos = __pos;
                let mut __repeat_value = vec![];
                loop {
                    let __pos = __repeat_pos;
                    let __pos = if __repeat_value.len() > 0 {
                        let __sep_res = {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = slice_eq(__input, __state, __pos, ",");
                                    match __seq_res {
                                        Matched(__pos, _) => __parse__(__input, __state, __pos, env),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __sep_res {
                            Matched(__newpos, _) => __newpos,
                            Failed => break,
                        }
                    } else {
                        __pos
                    };
                    let __step_res = __parse_parameter_declaration(__input, __state, __pos, env);
                    match __step_res {
                        Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                            __repeat_value.push(__value);
                        }
                        Failed => {
                            break;
                        }
                    }
                }
                if __repeat_value.len() >= 1 {
                    Matched(__repeat_pos, __repeat_value)
                } else {
                    Failed
                }
            };
            match __seq_res {
                Matched(__pos, e) => Matched(__pos, { e }),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, p) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_ellipsis(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, e) => Matched(__pos, { FunctionDeclarator { parameters: p, ellipsis: e } }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_pointer<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<DerivedDeclarator<T::Interned>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = Matched(__pos, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse_pointer0(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = Matched(__pos, __pos);
                        match __seq_res {
                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_pointer0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<DerivedDeclarator<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "*");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let __seq_res = {
                                let mut __repeat_pos = __pos;
                                let mut __repeat_value = vec![];
                                loop {
                                    let __pos = __repeat_pos;
                                    let __pos = if __repeat_value.len() > 0 {
                                        let __sep_res = __parse__(__input, __state, __pos, env);
                                        match __sep_res {
                                            Matched(__newpos, _) => __newpos,
                                            Failed => break,
                                        }
                                    } else {
                                        __pos
                                    };
                                    let __step_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = __parse_pointer_qualifier(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                            __repeat_value.push(__value);
                                        }
                                        Failed => {
                                            break;
                                        }
                                    }
                                }
                                Matched(__repeat_pos, __repeat_value)
                            };
                            match __seq_res {
                                Matched(__pos, e) => Matched(__pos, { e }),
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, q) => Matched(__pos, { DerivedDeclarator::Pointer(q) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_pointer_qualifier<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<PointerQualifier<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_type_qualifier(__input, __state, __pos, env);
            match __seq_res {
                Matched(__pos, q) => Matched(__pos, { PointerQualifier::TypeQualifier(q) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = {
                    let __seq_res = {
                        __state.suppress_fail += 1;
                        let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                        __state.suppress_fail -= 1;
                        match __assert_res {
                            Matched(_, __value) => Matched(__pos, __value),
                            Failed => Failed,
                        }
                    };
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = __parse_attribute_specifier(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, e) => Matched(__pos, { e }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, e) => Matched(__pos, { PointerQualifier::Extension(e) }),
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_ellipsis<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Ellipsis> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, ",");
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = slice_eq(__input, __state, __pos, "...");
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { Ellipsis::Some }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => Matched(__pos, { Ellipsis::None }),
        }
    }
}

fn __parse_parameter_declaration<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<ParameterDeclaration<T::Interned>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = Matched(__pos, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse_parameter_declaration0(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = Matched(__pos, __pos);
                        match __seq_res {
                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_parameter_declaration0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<ParameterDeclaration<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_declaration_specifiers(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, s) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_parameter_declarator(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, d) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = match {
                                            let __seq_res = {
                                                __state.suppress_fail += 1;
                                                let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                                __state.suppress_fail -= 1;
                                                match __assert_res {
                                                    Matched(_, __value) => Matched(__pos, __value),
                                                    Failed => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = __parse_attribute_specifier_list(__input, __state, __pos, env);
                                                    match __seq_res {
                                                        Matched(__pos, e) => Matched(__pos, { e }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        } {
                                            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                            Failed => Matched(__pos, None),
                                        };
                                        match __seq_res {
                                            Matched(__pos, a) => Matched(__pos, { ParameterDeclaration { specifiers: s, declarator: d, extensions: a.unwrap_or_default() } }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_parameter_declarator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Option<Node<Declarator<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_declarator(__input, __state, __pos, env);
            match __seq_res {
                Matched(__pos, d) => Matched(__pos, {
                    env.handle_declarator(&d, Symbol::Identifier);
                    Some(d)
                }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = __parse_abstract_declarator(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, d) => Matched(__pos, { Some(d) }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => Matched(__pos, { None }),
                }
            }
        }
    }
}

fn __parse_type_name<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<TypeName<T::Interned>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = Matched(__pos, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse_type_name0(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = Matched(__pos, __pos);
                        match __seq_res {
                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_type_name0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<TypeName<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_specifier_qualifiers(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, s) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = match __parse_abstract_declarator(__input, __state, __pos, env) {
                            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                            Failed => Matched(__pos, None),
                        };
                        match __seq_res {
                            Matched(__pos, d) => Matched(__pos, { TypeName { specifiers: s, declarator: d } }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_abstract_declarator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<Declarator<T::Interned>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = Matched(__pos, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse_abstract_declarator0(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = Matched(__pos, __pos);
                        match __seq_res {
                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_abstract_declarator0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Declarator<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let __seq_res = {
                    let mut __repeat_pos = __pos;
                    let mut __repeat_value = vec![];
                    loop {
                        let __pos = __repeat_pos;
                        let __pos = if __repeat_value.len() > 0 {
                            let __sep_res = __parse__(__input, __state, __pos, env);
                            match __sep_res {
                                Matched(__newpos, _) => __newpos,
                                Failed => break,
                            }
                        } else {
                            __pos
                        };
                        let __step_res = __parse_pointer(__input, __state, __pos, env);
                        match __step_res {
                            Matched(__newpos, __value) => {
                                __repeat_pos = __newpos;
                                __repeat_value.push(__value);
                            }
                            Failed => {
                                break;
                            }
                        }
                    }
                    Matched(__repeat_pos, __repeat_value)
                };
                match __seq_res {
                    Matched(__pos, e) => Matched(__pos, { e }),
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, p) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = {
                                let __seq_res = Matched(__pos, __pos);
                                match __seq_res {
                                    Matched(__pos, l) => {
                                        let __seq_res = __parse_direct_abstract_declarator(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, e) => {
                                                let __seq_res = Matched(__pos, __pos);
                                                match __seq_res {
                                                    Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, k) => {
                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = {
                                                let __seq_res = {
                                                    let mut __repeat_pos = __pos;
                                                    let mut __repeat_value = vec![];
                                                    loop {
                                                        let __pos = __repeat_pos;
                                                        let __pos = if __repeat_value.len() > 0 {
                                                            let __sep_res = __parse__(__input, __state, __pos, env);
                                                            match __sep_res {
                                                                Matched(__newpos, _) => __newpos,
                                                                Failed => break,
                                                            }
                                                        } else {
                                                            __pos
                                                        };
                                                        let __step_res = __parse_derived_abstract_declarator(__input, __state, __pos, env);
                                                        match __step_res {
                                                            Matched(__newpos, __value) => {
                                                                __repeat_pos = __newpos;
                                                                __repeat_value.push(__value);
                                                            }
                                                            Failed => {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    Matched(__repeat_pos, __repeat_value)
                                                };
                                                match __seq_res {
                                                    Matched(__pos, e) => Matched(__pos, { e }),
                                                    Failed => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, d) => Matched(__pos, { Declarator { kind: k, derived: concat(p, d), extensions: Vec::new() } }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __pos = if __repeat_value.len() > 0 {
                                    let __sep_res = __parse__(__input, __state, __pos, env);
                                    match __sep_res {
                                        Matched(__newpos, _) => __newpos,
                                        Failed => break,
                                    }
                                } else {
                                    __pos
                                };
                                let __step_res = __parse_pointer(__input, __state, __pos, env);
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            Matched(__repeat_pos, __repeat_value)
                        };
                        match __seq_res {
                            Matched(__pos, e) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    };
                    match __seq_res {
                        Matched(__pos, p) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, k) => {
                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = {
                                                let __seq_res = {
                                                    let mut __repeat_pos = __pos;
                                                    let mut __repeat_value = vec![];
                                                    loop {
                                                        let __pos = __repeat_pos;
                                                        let __pos = if __repeat_value.len() > 0 {
                                                            let __sep_res = __parse__(__input, __state, __pos, env);
                                                            match __sep_res {
                                                                Matched(__newpos, _) => __newpos,
                                                                Failed => break,
                                                            }
                                                        } else {
                                                            __pos
                                                        };
                                                        let __step_res = __parse_derived_abstract_declarator(__input, __state, __pos, env);
                                                        match __step_res {
                                                            Matched(__newpos, __value) => {
                                                                __repeat_pos = __newpos;
                                                                __repeat_value.push(__value);
                                                            }
                                                            Failed => {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    if __repeat_value.len() >= 1 {
                                                        Matched(__repeat_pos, __repeat_value)
                                                    } else {
                                                        Failed
                                                    }
                                                };
                                                match __seq_res {
                                                    Matched(__pos, e) => Matched(__pos, { e }),
                                                    Failed => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, d) => Matched(__pos, { Declarator { kind: Node::new(DeclaratorKind::Abstract, Span::span(k, k)), derived: concat(p, d), extensions: Vec::new() } }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __seq_res = {
                            let __seq_res = {
                                let mut __repeat_pos = __pos;
                                let mut __repeat_value = vec![];
                                loop {
                                    let __pos = __repeat_pos;
                                    let __pos = if __repeat_value.len() > 0 {
                                        let __sep_res = __parse__(__input, __state, __pos, env);
                                        match __sep_res {
                                            Matched(__newpos, _) => __newpos,
                                            Failed => break,
                                        }
                                    } else {
                                        __pos
                                    };
                                    let __step_res = __parse_pointer(__input, __state, __pos, env);
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                            __repeat_value.push(__value);
                                        }
                                        Failed => {
                                            break;
                                        }
                                    }
                                }
                                if __repeat_value.len() >= 1 {
                                    Matched(__repeat_pos, __repeat_value)
                                } else {
                                    Failed
                                }
                            };
                            match __seq_res {
                                Matched(__pos, e) => Matched(__pos, { e }),
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, p) => {
                                let __seq_res = Matched(__pos, __pos);
                                match __seq_res {
                                    Matched(__pos, k) => Matched(__pos, { Declarator { kind: Node::new(DeclaratorKind::Abstract, Span::span(k, k)), derived: p, extensions: Vec::new() } }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
            }
        }
    }
}

fn __parse_direct_abstract_declarator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<DeclaratorKind<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "(");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_abstract_declarator(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, d) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                        match __seq_res {
                                            Matched(__pos, _) => Matched(__pos, { DeclaratorKind::Declarator(Box::new(d)) }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_derived_abstract_declarator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<DerivedDeclarator<T::Interned>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = Matched(__pos, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse_derived_abstract_declarator0(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = Matched(__pos, __pos);
                        match __seq_res {
                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_derived_abstract_declarator0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<DerivedDeclarator<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, "[");
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = {
                                let __seq_res = Matched(__pos, __pos);
                                match __seq_res {
                                    Matched(__pos, l) => {
                                        let __seq_res = __parse_abstract_array_declarator(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, e) => {
                                                let __seq_res = Matched(__pos, __pos);
                                                match __seq_res {
                                                    Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, a) => Matched(__pos, { DerivedDeclarator::Array(a) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = slice_eq(__input, __state, __pos, "(");
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse__(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = {
                                    let __seq_res = Matched(__pos, __pos);
                                    match __seq_res {
                                        Matched(__pos, l) => {
                                            let __seq_res = __parse_abstract_function_declarator(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, e) => {
                                                    let __seq_res = Matched(__pos, __pos);
                                                    match __seq_res {
                                                        Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, d) => {
                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                match __seq_res {
                                                    Matched(__pos, _) => Matched(__pos, { DerivedDeclarator::Function(d) }),
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_abstract_array_declarator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<ArrayDeclarator<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let __seq_res = {
                    let mut __repeat_pos = __pos;
                    let mut __repeat_value = vec![];
                    loop {
                        let __pos = __repeat_pos;
                        let __pos = if __repeat_value.len() > 0 {
                            let __sep_res = __parse__(__input, __state, __pos, env);
                            match __sep_res {
                                Matched(__newpos, _) => __newpos,
                                Failed => break,
                            }
                        } else {
                            __pos
                        };
                        let __step_res = __parse_type_qualifier(__input, __state, __pos, env);
                        match __step_res {
                            Matched(__newpos, __value) => {
                                __repeat_pos = __newpos;
                                __repeat_value.push(__value);
                            }
                            Failed => {
                                break;
                            }
                        }
                    }
                    Matched(__repeat_pos, __repeat_value)
                };
                match __seq_res {
                    Matched(__pos, e) => Matched(__pos, { e }),
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, q) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = slice_eq(__input, __state, __pos, "]");
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { ArrayDeclarator { qualifiers: q, size: ArraySize::Unknown } }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __pos = if __repeat_value.len() > 0 {
                                    let __sep_res = __parse__(__input, __state, __pos, env);
                                    match __sep_res {
                                        Matched(__newpos, _) => __newpos,
                                        Failed => break,
                                    }
                                } else {
                                    __pos
                                };
                                let __step_res = __parse_type_qualifier(__input, __state, __pos, env);
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            Matched(__repeat_pos, __repeat_value)
                        };
                        match __seq_res {
                            Matched(__pos, e) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    };
                    match __seq_res {
                        Matched(__pos, q) => {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = __parse_assignment_expression(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = slice_eq(__input, __state, __pos, "]");
                                                    match __seq_res {
                                                        Matched(__pos, _) => Matched(__pos, { ArrayDeclarator { qualifiers: q, size: ArraySize::VariableExpression(e) } }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let res = {
                                    let __seq_res = slice_eq(__input, __state, __pos, "static");
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = {
                                                __state.suppress_fail += 1;
                                                let __assert_res = if __input.len() > __pos {
                                                    let (__ch, __next) = char_range_at(__input, __pos);
                                                    match __ch {
                                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                    }
                                                } else {
                                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                };
                                                __state.suppress_fail -= 1;
                                                match __assert_res {
                                                    Failed => Matched(__pos, ()),
                                                    Matched(..) => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { e }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                __state.suppress_fail -= 1;
                                res
                            };
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = {
                                                let __seq_res = {
                                                    let mut __repeat_pos = __pos;
                                                    let mut __repeat_value = vec![];
                                                    loop {
                                                        let __pos = __repeat_pos;
                                                        let __pos = if __repeat_value.len() > 0 {
                                                            let __sep_res = __parse__(__input, __state, __pos, env);
                                                            match __sep_res {
                                                                Matched(__newpos, _) => __newpos,
                                                                Failed => break,
                                                            }
                                                        } else {
                                                            __pos
                                                        };
                                                        let __step_res = __parse_type_qualifier(__input, __state, __pos, env);
                                                        match __step_res {
                                                            Matched(__newpos, __value) => {
                                                                __repeat_pos = __newpos;
                                                                __repeat_value.push(__value);
                                                            }
                                                            Failed => {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    Matched(__repeat_pos, __repeat_value)
                                                };
                                                match __seq_res {
                                                    Matched(__pos, e) => Matched(__pos, { e }),
                                                    Failed => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, q) => {
                                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                                    match __seq_res {
                                                        Matched(__pos, _) => {
                                                            let __seq_res = __parse_assignment_expression(__input, __state, __pos, env);
                                                            match __seq_res {
                                                                Matched(__pos, e) => {
                                                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                                                    match __seq_res {
                                                                        Matched(__pos, _) => {
                                                                            let __seq_res = slice_eq(__input, __state, __pos, "]");
                                                                            match __seq_res {
                                                                                Matched(__pos, _) => Matched(__pos, { ArrayDeclarator { qualifiers: q, size: ArraySize::StaticExpression(e) } }),
                                                                                Failed => Failed,
                                                                            }
                                                                        }
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = {
                                    let __seq_res = {
                                        let __seq_res = {
                                            let mut __repeat_pos = __pos;
                                            let mut __repeat_value = vec![];
                                            loop {
                                                let __pos = __repeat_pos;
                                                let __pos = if __repeat_value.len() > 0 {
                                                    let __sep_res = __parse__(__input, __state, __pos, env);
                                                    match __sep_res {
                                                        Matched(__newpos, _) => __newpos,
                                                        Failed => break,
                                                    }
                                                } else {
                                                    __pos
                                                };
                                                let __step_res = __parse_type_qualifier(__input, __state, __pos, env);
                                                match __step_res {
                                                    Matched(__newpos, __value) => {
                                                        __repeat_pos = __newpos;
                                                        __repeat_value.push(__value);
                                                    }
                                                    Failed => {
                                                        break;
                                                    }
                                                }
                                            }
                                            if __repeat_value.len() >= 1 {
                                                Matched(__repeat_pos, __repeat_value)
                                            } else {
                                                Failed
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, e) => Matched(__pos, { e }),
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, q) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = {
                                                        __state.suppress_fail += 1;
                                                        let res = {
                                                            let __seq_res = slice_eq(__input, __state, __pos, "static");
                                                            match __seq_res {
                                                                Matched(__pos, e) => {
                                                                    let __seq_res = {
                                                                        __state.suppress_fail += 1;
                                                                        let __assert_res = if __input.len() > __pos {
                                                                            let (__ch, __next) = char_range_at(__input, __pos);
                                                                            match __ch {
                                                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                                            }
                                                                        } else {
                                                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                                        };
                                                                        __state.suppress_fail -= 1;
                                                                        match __assert_res {
                                                                            Failed => Matched(__pos, ()),
                                                                            Matched(..) => Failed,
                                                                        }
                                                                    };
                                                                    match __seq_res {
                                                                        Matched(__pos, _) => Matched(__pos, { e }),
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        };
                                                        __state.suppress_fail -= 1;
                                                        res
                                                    };
                                                    match __seq_res {
                                                        Matched(__pos, _) => {
                                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                                            match __seq_res {
                                                                Matched(__pos, _) => {
                                                                    let __seq_res = __parse_assignment_expression(__input, __state, __pos, env);
                                                                    match __seq_res {
                                                                        Matched(__pos, e) => {
                                                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                                                            match __seq_res {
                                                                                Matched(__pos, _) => {
                                                                                    let __seq_res = slice_eq(__input, __state, __pos, "]");
                                                                                    match __seq_res {
                                                                                        Matched(__pos, _) => Matched(__pos, { ArrayDeclarator { qualifiers: q, size: ArraySize::StaticExpression(e) } }),
                                                                                        Failed => Failed,
                                                                                    }
                                                                                }
                                                                                Failed => Failed,
                                                                            }
                                                                        }
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __seq_res = slice_eq(__input, __state, __pos, "*");
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = slice_eq(__input, __state, __pos, "]");
                                                        match __seq_res {
                                                            Matched(__pos, _) => Matched(__pos, { ArrayDeclarator { qualifiers: Vec::new(), size: ArraySize::VariableUnknown } }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_abstract_function_declarator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<FunctionDeclarator<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let __seq_res = {
                    let mut __repeat_pos = __pos;
                    let mut __repeat_value = vec![];
                    loop {
                        let __pos = __repeat_pos;
                        let __pos = if __repeat_value.len() > 0 {
                            let __sep_res = {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = slice_eq(__input, __state, __pos, ",");
                                        match __seq_res {
                                            Matched(__pos, _) => __parse__(__input, __state, __pos, env),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            };
                            match __sep_res {
                                Matched(__newpos, _) => __newpos,
                                Failed => break,
                            }
                        } else {
                            __pos
                        };
                        let __step_res = __parse_parameter_declaration(__input, __state, __pos, env);
                        match __step_res {
                            Matched(__newpos, __value) => {
                                __repeat_pos = __newpos;
                                __repeat_value.push(__value);
                            }
                            Failed => {
                                break;
                            }
                        }
                    }
                    if __repeat_value.len() >= 1 {
                        Matched(__repeat_pos, __repeat_value)
                    } else {
                        Failed
                    }
                };
                match __seq_res {
                    Matched(__pos, e) => Matched(__pos, { e }),
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, p) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = __parse_ellipsis(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, e) => Matched(__pos, { FunctionDeclarator { parameters: p, ellipsis: e } }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => Matched(__pos, { FunctionDeclarator { parameters: Vec::new(), ellipsis: Ellipsis::None } }),
        }
    }
}

fn __parse_typedef_name<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<Identifier<T::Interned>>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            __state.suppress_fail += 1;
            let res = __parse_typedef_name0(__input, __state, __pos, env);
            __state.suppress_fail -= 1;
            res
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                __state.mark_failure(__pos, "<typedef_name>");
                Failed
            }
        }
    }
}

fn __parse_typedef_name0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<Identifier<T::Interned>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_identifier(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, i) => {
                match {
                    if env.is_typename(&i.node.name) {
                        Ok(i)
                    } else {
                        Err("<unused>")
                    }
                } {
                    Ok(res) => Matched(__pos, res),
                    Err(expected) => {
                        __state.mark_failure(__pos, expected);
                        Failed
                    }
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_initializer<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Initializer<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_assignment_expression(__input, __state, __pos, env);
            match __seq_res {
                Matched(__pos, e) => Matched(__pos, { Initializer::Expression(e) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = slice_eq(__input, __state, __pos, "{");
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = {
                                            let mut __repeat_pos = __pos;
                                            let mut __repeat_value = vec![];
                                            loop {
                                                let __pos = __repeat_pos;
                                                let __pos = if __repeat_value.len() > 0 {
                                                    let __sep_res = {
                                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = slice_eq(__input, __state, __pos, ",");
                                                                match __seq_res {
                                                                    Matched(__pos, _) => __parse__(__input, __state, __pos, env),
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    };
                                                    match __sep_res {
                                                        Matched(__newpos, _) => __newpos,
                                                        Failed => break,
                                                    }
                                                } else {
                                                    __pos
                                                };
                                                let __step_res = {
                                                    let __seq_res = Matched(__pos, __pos);
                                                    match __seq_res {
                                                        Matched(__pos, l) => {
                                                            let __seq_res = __parse_initializer_list_item(__input, __state, __pos, env);
                                                            match __seq_res {
                                                                Matched(__pos, e) => {
                                                                    let __seq_res = Matched(__pos, __pos);
                                                                    match __seq_res {
                                                                        Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                };
                                                match __step_res {
                                                    Matched(__newpos, __value) => {
                                                        __repeat_pos = __newpos;
                                                        __repeat_value.push(__value);
                                                    }
                                                    Failed => {
                                                        break;
                                                    }
                                                }
                                            }
                                            if __repeat_value.len() >= 1 {
                                                Matched(__repeat_pos, __repeat_value)
                                            } else {
                                                Failed
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, e) => Matched(__pos, { e }),
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, i) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = match slice_eq(__input, __state, __pos, ",") {
                                                        Matched(__newpos, _) => Matched(__newpos, ()),
                                                        Failed => Matched(__pos, ()),
                                                    };
                                                    match __seq_res {
                                                        Matched(__pos, _) => {
                                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                                            match __seq_res {
                                                                Matched(__pos, _) => {
                                                                    let __seq_res = slice_eq(__input, __state, __pos, "}");
                                                                    match __seq_res {
                                                                        Matched(__pos, _) => Matched(__pos, { Initializer::List(i) }),
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __seq_res = {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                __state.suppress_fail -= 1;
                                match __assert_res {
                                    Matched(_, __value) => Matched(__pos, __value),
                                    Failed => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = slice_eq(__input, __state, __pos, "{");
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => slice_eq(__input, __state, __pos, "}"),
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, e) => Matched(__pos, { e }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { Initializer::List(Vec::new()) }),
                            Failed => Failed,
                        }
                    }
                }
            }
        }
    }
}

fn __parse_initializer_list_item<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<InitializerListItem<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = match __parse_designation(__input, __state, __pos, env) {
            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
            Failed => Matched(__pos, None),
        };
        match __seq_res {
            Matched(__pos, d) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, l) => {
                                    let __seq_res = __parse_initializer(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = Matched(__pos, __pos);
                                            match __seq_res {
                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, i) => Matched(__pos, { InitializerListItem { designation: d.unwrap_or_default(), initializer: Box::new(i) } }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_designation<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Vec<Node<Designator<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let __seq_res = {
                    let mut __repeat_pos = __pos;
                    let mut __repeat_value = vec![];
                    loop {
                        let __pos = __repeat_pos;
                        let __pos = if __repeat_value.len() > 0 {
                            let __sep_res = __parse__(__input, __state, __pos, env);
                            match __sep_res {
                                Matched(__newpos, _) => __newpos,
                                Failed => break,
                            }
                        } else {
                            __pos
                        };
                        let __step_res = {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, l) => {
                                    let __seq_res = __parse_designator(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = Matched(__pos, __pos);
                                            match __seq_res {
                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __step_res {
                            Matched(__newpos, __value) => {
                                __repeat_pos = __newpos;
                                __repeat_value.push(__value);
                            }
                            Failed => {
                                break;
                            }
                        }
                    }
                    if __repeat_value.len() >= 1 {
                        Matched(__repeat_pos, __repeat_value)
                    } else {
                        Failed
                    }
                };
                match __seq_res {
                    Matched(__pos, e) => Matched(__pos, { e }),
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, d) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = slice_eq(__input, __state, __pos, "=");
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { d }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Matched(_, __value) => Matched(__pos, __value),
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = {
                                    let __seq_res = Matched(__pos, __pos);
                                    match __seq_res {
                                        Matched(__pos, l) => {
                                            let __seq_res = __parse_colon_designation(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, e) => {
                                                    let __seq_res = Matched(__pos, __pos);
                                                    match __seq_res {
                                                        Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, e) => Matched(__pos, { e }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    };
                    match __seq_res {
                        Matched(__pos, d) => Matched(__pos, { vec![d] }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __seq_res = {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                __state.suppress_fail -= 1;
                                match __assert_res {
                                    Matched(_, __value) => Matched(__pos, __value),
                                    Failed => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = __parse_array_designator(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, e) => Matched(__pos, { e }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, d) => Matched(__pos, { vec![d] }),
                            Failed => Failed,
                        }
                    }
                }
            }
        }
    }
}

fn __parse_colon_designation<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Designator<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_identifier(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, i) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, ":");
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { Designator::Member(i) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_designator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Designator<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_array_designator(__input, __state, __pos, env);
            match __seq_res {
                Matched(__pos, d) => Matched(__pos, { d }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = slice_eq(__input, __state, __pos, ".");
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse__(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse_identifier(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, i) => Matched(__pos, { Designator::Member(i) }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_array_designator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Designator<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "[");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, l) => {
                                    let __seq_res = __parse_constant_expression0(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = Matched(__pos, __pos);
                                            match __seq_res {
                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, a) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = match {
                                            let __seq_res = {
                                                __state.suppress_fail += 1;
                                                let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                                __state.suppress_fail -= 1;
                                                match __assert_res {
                                                    Matched(_, __value) => Matched(__pos, __value),
                                                    Failed => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = __parse_range_designator_ext(__input, __state, __pos, env);
                                                    match __seq_res {
                                                        Matched(__pos, e) => Matched(__pos, { e }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        } {
                                            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                            Failed => Matched(__pos, None),
                                        };
                                        match __seq_res {
                                            Matched(__pos, b) => {
                                                let __seq_res = slice_eq(__input, __state, __pos, "]");
                                                match __seq_res {
                                                    Matched(__pos, _) => Matched(__pos, {
                                                        match b {
                                                            Some(b) => {
                                                                let span = Span::span(a.span.start, b.span.end);
                                                                Designator::Range(Node::new(RangeDesignator { from: a, to: b }, span))
                                                            }
                                                            None => Designator::Index(a),
                                                        }
                                                    }),
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_range_designator_ext<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<Expression<T::Interned>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "...");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, l) => {
                                    let __seq_res = __parse_constant_expression0(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = Matched(__pos, __pos);
                                            match __seq_res {
                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, e) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_static_assert<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<StaticAssert<T::Interned>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = Matched(__pos, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse_static_assert0(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = Matched(__pos, __pos);
                        match __seq_res {
                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_static_assert0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<StaticAssert<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = match {
            let __seq_res = {
                __state.suppress_fail += 1;
                let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                __state.suppress_fail -= 1;
                match __assert_res {
                    Matched(_, __value) => Matched(__pos, __value),
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = {
                        __state.suppress_fail += 1;
                        let res = {
                            let __seq_res = slice_eq(__input, __state, __pos, "__extension__");
                            match __seq_res {
                                Matched(__pos, e) => {
                                    let __seq_res = {
                                        __state.suppress_fail += 1;
                                        let __assert_res = if __input.len() > __pos {
                                            let (__ch, __next) = char_range_at(__input, __pos);
                                            match __ch {
                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                            }
                                        } else {
                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                        };
                                        __state.suppress_fail -= 1;
                                        match __assert_res {
                                            Failed => Matched(__pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, { e }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        __state.suppress_fail -= 1;
                        res
                    };
                    match __seq_res {
                        Matched(__pos, e) => Matched(__pos, { e }),
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        } {
            Matched(__newpos, _) => Matched(__newpos, ()),
            Failed => Matched(__pos, ()),
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let res = {
                                let __seq_res = slice_eq(__input, __state, __pos, "_Static_assert");
                                match __seq_res {
                                    Matched(__pos, e) => {
                                        let __seq_res = {
                                            __state.suppress_fail += 1;
                                            let __assert_res = if __input.len() > __pos {
                                                let (__ch, __next) = char_range_at(__input, __pos);
                                                match __ch {
                                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                }
                                            } else {
                                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                            };
                                            __state.suppress_fail -= 1;
                                            match __assert_res {
                                                Failed => Matched(__pos, ()),
                                                Matched(..) => Failed,
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, _) => Matched(__pos, { e }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            };
                            __state.suppress_fail -= 1;
                            res
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = slice_eq(__input, __state, __pos, "(");
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = __parse_constant_expression(__input, __state, __pos, env);
                                                        match __seq_res {
                                                            Matched(__pos, e) => {
                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, _) => {
                                                                        let __seq_res = slice_eq(__input, __state, __pos, ",");
                                                                        match __seq_res {
                                                                            Matched(__pos, _) => {
                                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                match __seq_res {
                                                                                    Matched(__pos, _) => {
                                                                                        let __seq_res = __parse_string_literal(__input, __state, __pos, env);
                                                                                        match __seq_res {
                                                                                            Matched(__pos, s) => {
                                                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                                match __seq_res {
                                                                                                    Matched(__pos, _) => {
                                                                                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                                                                        match __seq_res {
                                                                                                            Matched(__pos, _) => {
                                                                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                                                match __seq_res {
                                                                                                                    Matched(__pos, _) => {
                                                                                                                        let __seq_res = slice_eq(__input, __state, __pos, ";");
                                                                                                                        match __seq_res {
                                                                                                                            Matched(__pos, _) => Matched(__pos, { StaticAssert { expression: e, message: s } }),
                                                                                                                            Failed => Failed,
                                                                                                                        }
                                                                                                                    }
                                                                                                                    Failed => Failed,
                                                                                                                }
                                                                                                            }
                                                                                                            Failed => Failed,
                                                                                                        }
                                                                                                    }
                                                                                                    Failed => Failed,
                                                                                                }
                                                                                            }
                                                                                            Failed => Failed,
                                                                                        }
                                                                                    }
                                                                                    Failed => Failed,
                                                                                }
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_statement<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Box<Node<Statement<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_statement0(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, e) => Matched(__pos, { Box::new(e) }),
            Failed => Failed,
        }
    }
}

fn __parse_statement0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Statement<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let __seq_res = Matched(__pos, __pos);
                match __seq_res {
                    Matched(__pos, l) => {
                        let __seq_res = __parse_labeled_statement(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, e) => {
                                let __seq_res = Matched(__pos, __pos);
                                match __seq_res {
                                    Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, s) => Matched(__pos, { Statement::Labeled(s) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = Matched(__pos, {
                        env.enter_scope();
                    });
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = match __parse_compound_statement(__input, __state, __pos, env) {
                                Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                Failed => Matched(__pos, None),
                            };
                            match __seq_res {
                                Matched(__pos, e) => {
                                    match {
                                        env.leave_scope();
                                        e.ok_or("")
                                    } {
                                        Ok(res) => Matched(__pos, res),
                                        Err(expected) => {
                                            __state.mark_failure(__pos, expected);
                                            Failed
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = __parse_expression_statement(__input, __state, __pos, env);
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = {
                                    let __seq_res = Matched(__pos, {
                                        env.enter_scope();
                                    });
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = match __parse_selection_statement(__input, __state, __pos, env) {
                                                Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                                Failed => Matched(__pos, None),
                                            };
                                            match __seq_res {
                                                Matched(__pos, e) => {
                                                    match {
                                                        env.leave_scope();
                                                        e.ok_or("")
                                                    } {
                                                        Ok(res) => Matched(__pos, res),
                                                        Err(expected) => {
                                                            __state.mark_failure(__pos, expected);
                                                            Failed
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __choice_res = {
                                            let __seq_res = Matched(__pos, {
                                                env.enter_scope();
                                            });
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = match __parse_iteration_statement(__input, __state, __pos, env) {
                                                        Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                                        Failed => Matched(__pos, None),
                                                    };
                                                    match __seq_res {
                                                        Matched(__pos, e) => {
                                                            match {
                                                                env.leave_scope();
                                                                e.ok_or("")
                                                            } {
                                                                Ok(res) => Matched(__pos, res),
                                                                Err(expected) => {
                                                                    __state.mark_failure(__pos, expected);
                                                                    Failed
                                                                }
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        };
                                        match __choice_res {
                                            Matched(__pos, __value) => Matched(__pos, __value),
                                            Failed => {
                                                let __choice_res = __parse_jump_statement(__input, __state, __pos, env);
                                                match __choice_res {
                                                    Matched(__pos, __value) => Matched(__pos, __value),
                                                    Failed => {
                                                        let __seq_res = {
                                                            __state.suppress_fail += 1;
                                                            let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                                                            __state.suppress_fail -= 1;
                                                            match __assert_res {
                                                                Matched(_, __value) => Matched(__pos, __value),
                                                                Failed => Failed,
                                                            }
                                                        };
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = __parse_asm_statement(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, e) => Matched(__pos, { e }),
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_labeled_statement<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<LabeledStatement<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_label(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, ":");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = __parse_statement(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, s) => Matched(__pos, { LabeledStatement { label: l, statement: s } }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_label<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Label<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_identifier(__input, __state, __pos, env);
            match __seq_res {
                Matched(__pos, i) => Matched(__pos, { Label::Identifier(i) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = {
                        __state.suppress_fail += 1;
                        let res = {
                            let __seq_res = slice_eq(__input, __state, __pos, "case");
                            match __seq_res {
                                Matched(__pos, e) => {
                                    let __seq_res = {
                                        __state.suppress_fail += 1;
                                        let __assert_res = if __input.len() > __pos {
                                            let (__ch, __next) = char_range_at(__input, __pos);
                                            match __ch {
                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                            }
                                        } else {
                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                        };
                                        __state.suppress_fail -= 1;
                                        match __assert_res {
                                            Failed => Matched(__pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, { e }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        __state.suppress_fail -= 1;
                        res
                    };
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = __parse_constant_expression(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, e) => Matched(__pos, { Label::Case(e) }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let res = {
                                let __seq_res = slice_eq(__input, __state, __pos, "default");
                                match __seq_res {
                                    Matched(__pos, e) => {
                                        let __seq_res = {
                                            __state.suppress_fail += 1;
                                            let __assert_res = if __input.len() > __pos {
                                                let (__ch, __next) = char_range_at(__input, __pos);
                                                match __ch {
                                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                }
                                            } else {
                                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                            };
                                            __state.suppress_fail -= 1;
                                            match __assert_res {
                                                Failed => Matched(__pos, ()),
                                                Matched(..) => Failed,
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, _) => Matched(__pos, { e }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            };
                            __state.suppress_fail -= 1;
                            res
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { Label::Default }),
                            Failed => Failed,
                        }
                    }
                }
            }
        }
    }
}

fn __parse_compound_statement<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Statement<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "{");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let __seq_res = {
                                let mut __repeat_pos = __pos;
                                let mut __repeat_value = vec![];
                                loop {
                                    let __pos = __repeat_pos;
                                    let __pos = if __repeat_value.len() > 0 {
                                        let __sep_res = __parse__(__input, __state, __pos, env);
                                        match __sep_res {
                                            Matched(__newpos, _) => __newpos,
                                            Failed => break,
                                        }
                                    } else {
                                        __pos
                                    };
                                    let __step_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = __parse_block_item(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                            __repeat_value.push(__value);
                                        }
                                        Failed => {
                                            break;
                                        }
                                    }
                                }
                                Matched(__repeat_pos, __repeat_value)
                            };
                            match __seq_res {
                                Matched(__pos, e) => Matched(__pos, { e }),
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, b) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = slice_eq(__input, __state, __pos, "}");
                                        match __seq_res {
                                            Matched(__pos, _) => Matched(__pos, { Statement::Compound(b) }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_block_item<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<BlockItem<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_declaration(__input, __state, __pos, env);
            match __seq_res {
                Matched(__pos, d) => Matched(__pos, { BlockItem::Declaration(d) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = __parse_static_assert(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, s) => Matched(__pos, { BlockItem::StaticAssert(s) }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __seq_res = {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, l) => {
                                    let __seq_res = __parse_statement0(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = Matched(__pos, __pos);
                                            match __seq_res {
                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, s) => Matched(__pos, { BlockItem::Statement(s) }),
                            Failed => Failed,
                        }
                    }
                }
            }
        }
    }
}

fn __parse_expression_statement<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Statement<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = match __parse_expression(__input, __state, __pos, env) {
            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
            Failed => Matched(__pos, None),
        };
        match __seq_res {
            Matched(__pos, e) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, ";");
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { Statement::Expression(e) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_selection_statement<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Statement<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let __seq_res = Matched(__pos, __pos);
                match __seq_res {
                    Matched(__pos, l) => {
                        let __seq_res = __parse_if_statement(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, e) => {
                                let __seq_res = Matched(__pos, __pos);
                                match __seq_res {
                                    Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, s) => Matched(__pos, { Statement::If(s) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = {
                    let __seq_res = Matched(__pos, __pos);
                    match __seq_res {
                        Matched(__pos, l) => {
                            let __seq_res = __parse_switch_statement(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, e) => {
                                    let __seq_res = Matched(__pos, __pos);
                                    match __seq_res {
                                        Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, s) => Matched(__pos, { Statement::Switch(s) }),
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_if_statement<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<IfStatement<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let res = {
                let __seq_res = slice_eq(__input, __state, __pos, "if");
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                            };
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Failed => Matched(__pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "(");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = __parse_expression(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, e) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, _) => {
                                                                        let __seq_res = __parse_statement(__input, __state, __pos, env);
                                                                        match __seq_res {
                                                                            Matched(__pos, a) => {
                                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                match __seq_res {
                                                                                    Matched(__pos, _) => {
                                                                                        let __seq_res = match __parse_else_statement(__input, __state, __pos, env) {
                                                                                            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                                                                            Failed => Matched(__pos, None),
                                                                                        };
                                                                                        match __seq_res {
                                                                                            Matched(__pos, b) => Matched(__pos, { IfStatement { condition: e, then_statement: a, else_statement: b } }),
                                                                                            Failed => Failed,
                                                                                        }
                                                                                    }
                                                                                    Failed => Failed,
                                                                                }
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_else_statement<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Box<Node<Statement<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let res = {
                let __seq_res = slice_eq(__input, __state, __pos, "else");
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                            };
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Failed => Matched(__pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_statement(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, s) => Matched(__pos, { s }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_switch_statement<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<SwitchStatement<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let res = {
                let __seq_res = slice_eq(__input, __state, __pos, "switch");
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                            };
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Failed => Matched(__pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "(");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = __parse_expression(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, e) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, _) => {
                                                                        let __seq_res = __parse_statement(__input, __state, __pos, env);
                                                                        match __seq_res {
                                                                            Matched(__pos, s) => Matched(__pos, { SwitchStatement { expression: e, statement: s } }),
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_iteration_statement<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Statement<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let __seq_res = Matched(__pos, __pos);
                match __seq_res {
                    Matched(__pos, l) => {
                        let __seq_res = __parse_while_statement(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, e) => {
                                let __seq_res = Matched(__pos, __pos);
                                match __seq_res {
                                    Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, s) => Matched(__pos, { Statement::While(s) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = {
                        let __seq_res = Matched(__pos, __pos);
                        match __seq_res {
                            Matched(__pos, l) => {
                                let __seq_res = __parse_do_while_statement(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, e) => {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    };
                    match __seq_res {
                        Matched(__pos, s) => Matched(__pos, { Statement::DoWhile(s) }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __seq_res = {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, l) => {
                                    let __seq_res = __parse_for_statement(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = Matched(__pos, __pos);
                                            match __seq_res {
                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, s) => Matched(__pos, { Statement::For(s) }),
                            Failed => Failed,
                        }
                    }
                }
            }
        }
    }
}

fn __parse_while_statement<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<WhileStatement<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let res = {
                let __seq_res = slice_eq(__input, __state, __pos, "while");
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                            };
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Failed => Matched(__pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "(");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = __parse_expression(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, e) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, _) => {
                                                                        let __seq_res = __parse_statement(__input, __state, __pos, env);
                                                                        match __seq_res {
                                                                            Matched(__pos, s) => Matched(__pos, { WhileStatement { expression: e, statement: s } }),
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_do_while_statement<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<DoWhileStatement<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let res = {
                let __seq_res = slice_eq(__input, __state, __pos, "do");
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                            };
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Failed => Matched(__pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_statement(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, s) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = {
                                            __state.suppress_fail += 1;
                                            let res = {
                                                let __seq_res = slice_eq(__input, __state, __pos, "while");
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = {
                                                            __state.suppress_fail += 1;
                                                            let __assert_res = if __input.len() > __pos {
                                                                let (__ch, __next) = char_range_at(__input, __pos);
                                                                match __ch {
                                                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                                }
                                                            } else {
                                                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                            };
                                                            __state.suppress_fail -= 1;
                                                            match __assert_res {
                                                                Failed => Matched(__pos, ()),
                                                                Matched(..) => Failed,
                                                            }
                                                        };
                                                        match __seq_res {
                                                            Matched(__pos, _) => Matched(__pos, { e }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            };
                                            __state.suppress_fail -= 1;
                                            res
                                        };
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = slice_eq(__input, __state, __pos, "(");
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, _) => {
                                                                        let __seq_res = __parse_expression(__input, __state, __pos, env);
                                                                        match __seq_res {
                                                                            Matched(__pos, e) => {
                                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                match __seq_res {
                                                                                    Matched(__pos, _) => {
                                                                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                                                        match __seq_res {
                                                                                            Matched(__pos, _) => {
                                                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                                match __seq_res {
                                                                                                    Matched(__pos, _) => {
                                                                                                        let __seq_res = slice_eq(__input, __state, __pos, ";");
                                                                                                        match __seq_res {
                                                                                                            Matched(__pos, _) => Matched(__pos, { DoWhileStatement { statement: s, expression: e } }),
                                                                                                            Failed => Failed,
                                                                                                        }
                                                                                                    }
                                                                                                    Failed => Failed,
                                                                                                }
                                                                                            }
                                                                                            Failed => Failed,
                                                                                        }
                                                                                    }
                                                                                    Failed => Failed,
                                                                                }
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_for_statement<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<ForStatement<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let res = {
                let __seq_res = slice_eq(__input, __state, __pos, "for");
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                            };
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Failed => Matched(__pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "(");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = {
                                            let __seq_res = Matched(__pos, __pos);
                                            match __seq_res {
                                                Matched(__pos, l) => {
                                                    let __seq_res = __parse_for_initializer(__input, __state, __pos, env);
                                                    match __seq_res {
                                                        Matched(__pos, e) => {
                                                            let __seq_res = Matched(__pos, __pos);
                                                            match __seq_res {
                                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, a) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = match __parse_expression(__input, __state, __pos, env) {
                                                            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                                            Failed => Matched(__pos, None),
                                                        };
                                                        match __seq_res {
                                                            Matched(__pos, b) => {
                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, _) => {
                                                                        let __seq_res = slice_eq(__input, __state, __pos, ";");
                                                                        match __seq_res {
                                                                            Matched(__pos, _) => {
                                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                match __seq_res {
                                                                                    Matched(__pos, _) => {
                                                                                        let __seq_res = match __parse_expression(__input, __state, __pos, env) {
                                                                                            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                                                                            Failed => Matched(__pos, None),
                                                                                        };
                                                                                        match __seq_res {
                                                                                            Matched(__pos, c) => {
                                                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                                match __seq_res {
                                                                                                    Matched(__pos, _) => {
                                                                                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                                                                        match __seq_res {
                                                                                                            Matched(__pos, _) => {
                                                                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                                                match __seq_res {
                                                                                                                    Matched(__pos, _) => {
                                                                                                                        let __seq_res = __parse_statement(__input, __state, __pos, env);
                                                                                                                        match __seq_res {
                                                                                                                            Matched(__pos, s) => Matched(__pos, { ForStatement { initializer: a, condition: b, step: c, statement: s } }),
                                                                                                                            Failed => Failed,
                                                                                                                        }
                                                                                                                    }
                                                                                                                    Failed => Failed,
                                                                                                                }
                                                                                                            }
                                                                                                            Failed => Failed,
                                                                                                        }
                                                                                                    }
                                                                                                    Failed => Failed,
                                                                                                }
                                                                                            }
                                                                                            Failed => Failed,
                                                                                        }
                                                                                    }
                                                                                    Failed => Failed,
                                                                                }
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_for_initializer<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<ForInitializer<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_expression(__input, __state, __pos, env);
            match __seq_res {
                Matched(__pos, e) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = slice_eq(__input, __state, __pos, ";");
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { ForInitializer::Expression(e) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = __parse_declaration(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, d) => Matched(__pos, { ForInitializer::Declaration(d) }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = __parse_static_assert(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, s) => Matched(__pos, { ForInitializer::StaticAssert(s) }),
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __seq_res = slice_eq(__input, __state, __pos, ";");
                                match __seq_res {
                                    Matched(__pos, _) => Matched(__pos, { ForInitializer::Empty }),
                                    Failed => Failed,
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_jump_statement<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Statement<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                __state.suppress_fail += 1;
                let res = {
                    let __seq_res = slice_eq(__input, __state, __pos, "goto");
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let __assert_res = if __input.len() > __pos {
                                    let (__ch, __next) = char_range_at(__input, __pos);
                                    match __ch {
                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                    }
                                } else {
                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                };
                                __state.suppress_fail -= 1;
                                match __assert_res {
                                    Failed => Matched(__pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { e }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                __state.suppress_fail -= 1;
                res
            };
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = __parse_identifier(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, i) => {
                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = slice_eq(__input, __state, __pos, ";");
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { Statement::Goto(i) }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = {
                        __state.suppress_fail += 1;
                        let res = {
                            let __seq_res = slice_eq(__input, __state, __pos, "continue");
                            match __seq_res {
                                Matched(__pos, e) => {
                                    let __seq_res = {
                                        __state.suppress_fail += 1;
                                        let __assert_res = if __input.len() > __pos {
                                            let (__ch, __next) = char_range_at(__input, __pos);
                                            match __ch {
                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                            }
                                        } else {
                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                        };
                                        __state.suppress_fail -= 1;
                                        match __assert_res {
                                            Failed => Matched(__pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, { e }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        __state.suppress_fail -= 1;
                        res
                    };
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = slice_eq(__input, __state, __pos, ";");
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, { Statement::Continue }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let res = {
                                    let __seq_res = slice_eq(__input, __state, __pos, "break");
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = {
                                                __state.suppress_fail += 1;
                                                let __assert_res = if __input.len() > __pos {
                                                    let (__ch, __next) = char_range_at(__input, __pos);
                                                    match __ch {
                                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                    }
                                                } else {
                                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                };
                                                __state.suppress_fail -= 1;
                                                match __assert_res {
                                                    Failed => Matched(__pos, ()),
                                                    Matched(..) => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { e }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                __state.suppress_fail -= 1;
                                res
                            };
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = slice_eq(__input, __state, __pos, ";");
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { Statement::Break }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __seq_res = {
                                    __state.suppress_fail += 1;
                                    let res = {
                                        let __seq_res = slice_eq(__input, __state, __pos, "return");
                                        match __seq_res {
                                            Matched(__pos, e) => {
                                                let __seq_res = {
                                                    __state.suppress_fail += 1;
                                                    let __assert_res = if __input.len() > __pos {
                                                        let (__ch, __next) = char_range_at(__input, __pos);
                                                        match __ch {
                                                            '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                            _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                        }
                                                    } else {
                                                        __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                    };
                                                    __state.suppress_fail -= 1;
                                                    match __assert_res {
                                                        Failed => Matched(__pos, ()),
                                                        Matched(..) => Failed,
                                                    }
                                                };
                                                match __seq_res {
                                                    Matched(__pos, _) => Matched(__pos, { e }),
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    __state.suppress_fail -= 1;
                                    res
                                };
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = match __parse_expression(__input, __state, __pos, env) {
                                                    Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                                    Failed => Matched(__pos, None),
                                                };
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = slice_eq(__input, __state, __pos, ";");
                                                                match __seq_res {
                                                                    Matched(__pos, _) => Matched(__pos, { Statement::Return(e) }),
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_translation_unit<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<TranslationUnit<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = match __parse_directive(__input, __state, __pos, env) {
            Matched(__newpos, _) => Matched(__newpos, ()),
            Failed => Matched(__pos, ()),
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let __seq_res = {
                                let mut __repeat_pos = __pos;
                                let mut __repeat_value = vec![];
                                loop {
                                    let __pos = __repeat_pos;
                                    let __pos = if __repeat_value.len() > 0 {
                                        let __sep_res = __parse__(__input, __state, __pos, env);
                                        match __sep_res {
                                            Matched(__newpos, _) => __newpos,
                                            Failed => break,
                                        }
                                    } else {
                                        __pos
                                    };
                                    let __step_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = __parse_external_declaration(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                            __repeat_value.push(__value);
                                        }
                                        Failed => {
                                            break;
                                        }
                                    }
                                }
                                Matched(__repeat_pos, __repeat_value)
                            };
                            match __seq_res {
                                Matched(__pos, e) => Matched(__pos, { e }),
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, d) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => Matched(__pos, { TranslationUnit(d) }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_external_declaration<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<ExternalDeclaration<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_declaration(__input, __state, __pos, env);
            match __seq_res {
                Matched(__pos, d) => Matched(__pos, { ExternalDeclaration::Declaration(d) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = __parse_static_assert(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, s) => Matched(__pos, { ExternalDeclaration::StaticAssert(s) }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __seq_res = {
                            let __seq_res = Matched(__pos, {
                                env.enter_scope();
                            });
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = match {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = __parse_function_definition(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    } {
                                        Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                        Failed => Matched(__pos, None),
                                    };
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            match {
                                                env.leave_scope();
                                                e.ok_or("")
                                            } {
                                                Ok(res) => Matched(__pos, res),
                                                Err(expected) => {
                                                    __state.mark_failure(__pos, expected);
                                                    Failed
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, d) => Matched(__pos, { ExternalDeclaration::FunctionDefinition(d) }),
                            Failed => Failed,
                        }
                    }
                }
            }
        }
    }
}

fn __parse_function_definition<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<FunctionDefinition<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = match {
            let __seq_res = {
                __state.suppress_fail += 1;
                let __assert_res = __parse_gnu_guard(__input, __state, __pos, env);
                __state.suppress_fail -= 1;
                match __assert_res {
                    Matched(_, __value) => Matched(__pos, __value),
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = {
                        __state.suppress_fail += 1;
                        let res = {
                            let __seq_res = slice_eq(__input, __state, __pos, "__extension__");
                            match __seq_res {
                                Matched(__pos, e) => {
                                    let __seq_res = {
                                        __state.suppress_fail += 1;
                                        let __assert_res = if __input.len() > __pos {
                                            let (__ch, __next) = char_range_at(__input, __pos);
                                            match __ch {
                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                            }
                                        } else {
                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                        };
                                        __state.suppress_fail -= 1;
                                        match __assert_res {
                                            Failed => Matched(__pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, { e }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        __state.suppress_fail -= 1;
                        res
                    };
                    match __seq_res {
                        Matched(__pos, e) => Matched(__pos, { e }),
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        } {
            Matched(__newpos, _) => Matched(__newpos, ()),
            Failed => Matched(__pos, ()),
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_declaration_specifiers(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, a) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = __parse_declarator(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, b) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = {
                                                            let __seq_res = {
                                                                let mut __repeat_pos = __pos;
                                                                let mut __repeat_value = vec![];
                                                                loop {
                                                                    let __pos = __repeat_pos;
                                                                    let __pos = if __repeat_value.len() > 0 {
                                                                        let __sep_res = __parse__(__input, __state, __pos, env);
                                                                        match __sep_res {
                                                                            Matched(__newpos, _) => __newpos,
                                                                            Failed => break,
                                                                        }
                                                                    } else {
                                                                        __pos
                                                                    };
                                                                    let __step_res = __parse_declaration(__input, __state, __pos, env);
                                                                    match __step_res {
                                                                        Matched(__newpos, __value) => {
                                                                            __repeat_pos = __newpos;
                                                                            __repeat_value.push(__value);
                                                                        }
                                                                        Failed => {
                                                                            break;
                                                                        }
                                                                    }
                                                                }
                                                                Matched(__repeat_pos, __repeat_value)
                                                            };
                                                            match __seq_res {
                                                                Matched(__pos, e) => Matched(__pos, { e }),
                                                                Failed => Failed,
                                                            }
                                                        };
                                                        match __seq_res {
                                                            Matched(__pos, c) => {
                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, _) => {
                                                                        let __seq_res = {
                                                                            let __seq_res = Matched(__pos, __pos);
                                                                            match __seq_res {
                                                                                Matched(__pos, l) => {
                                                                                    let __seq_res = __parse_compound_statement(__input, __state, __pos, env);
                                                                                    match __seq_res {
                                                                                        Matched(__pos, e) => {
                                                                                            let __seq_res = Matched(__pos, __pos);
                                                                                            match __seq_res {
                                                                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                                                Failed => Failed,
                                                                                            }
                                                                                        }
                                                                                        Failed => Failed,
                                                                                    }
                                                                                }
                                                                                Failed => Failed,
                                                                            }
                                                                        };
                                                                        match __seq_res {
                                                                            Matched(__pos, d) => Matched(__pos, { FunctionDefinition { specifiers: a, declarator: b, declarations: c, statement: d } }),
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_gnu_guard<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    match {
        if env.extensions_gnu {
            Ok(())
        } else {
            Err("gnu extensions disabled")
        }
    } {
        Ok(res) => Matched(__pos, res),
        Err(expected) => {
            __state.mark_failure(__pos, expected);
            Failed
        }
    }
}

fn __parse_attribute_specifier_list<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Vec<Node<Extension<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = {
                let mut __repeat_pos = __pos;
                let mut __repeat_value = vec![];
                loop {
                    let __pos = __repeat_pos;
                    let __pos = if __repeat_value.len() > 0 {
                        let __sep_res = __parse__(__input, __state, __pos, env);
                        match __sep_res {
                            Matched(__newpos, _) => __newpos,
                            Failed => break,
                        }
                    } else {
                        __pos
                    };
                    let __step_res = __parse_attribute_specifier(__input, __state, __pos, env);
                    match __step_res {
                        Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                            __repeat_value.push(__value);
                        }
                        Failed => {
                            break;
                        }
                    }
                }
                Matched(__repeat_pos, __repeat_value)
            };
            match __seq_res {
                Matched(__pos, e) => Matched(__pos, { e }),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, a) => Matched(__pos, { a.into_iter().flat_map(|v| v).collect() }),
            Failed => Failed,
        }
    }
}

fn __parse_attribute_specifier<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Vec<Node<Extension<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let res = {
                let __seq_res = slice_eq(__input, __state, __pos, "__attribute__");
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                            };
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Failed => Matched(__pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "((");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = {
                                            let __seq_res = {
                                                let mut __repeat_pos = __pos;
                                                let mut __repeat_value = vec![];
                                                loop {
                                                    let __pos = __repeat_pos;
                                                    let __pos = if __repeat_value.len() > 0 {
                                                        let __sep_res = {
                                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                                            match __seq_res {
                                                                Matched(__pos, _) => {
                                                                    let __seq_res = slice_eq(__input, __state, __pos, ",");
                                                                    match __seq_res {
                                                                        Matched(__pos, _) => __parse__(__input, __state, __pos, env),
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        };
                                                        match __sep_res {
                                                            Matched(__newpos, _) => __newpos,
                                                            Failed => break,
                                                        }
                                                    } else {
                                                        __pos
                                                    };
                                                    let __step_res = {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, l) => {
                                                                let __seq_res = __parse_attribute(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, e) => {
                                                                        let __seq_res = Matched(__pos, __pos);
                                                                        match __seq_res {
                                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    };
                                                    match __step_res {
                                                        Matched(__newpos, __value) => {
                                                            __repeat_pos = __newpos;
                                                            __repeat_value.push(__value);
                                                        }
                                                        Failed => {
                                                            break;
                                                        }
                                                    }
                                                }
                                                Matched(__repeat_pos, __repeat_value)
                                            };
                                            match __seq_res {
                                                Matched(__pos, e) => Matched(__pos, { e }),
                                                Failed => Failed,
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, a) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = slice_eq(__input, __state, __pos, "))");
                                                        match __seq_res {
                                                            Matched(__pos, _) => Matched(__pos, { a }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_attribute<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Extension<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let __seq_res = {
                    __state.suppress_fail += 1;
                    let __assert_res = __parse_clang_guard(__input, __state, __pos, env);
                    __state.suppress_fail -= 1;
                    match __assert_res {
                        Matched(_, __value) => Matched(__pos, __value),
                        Failed => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, l) => {
                                    let __seq_res = __parse_attr_availability(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = Matched(__pos, __pos);
                                            match __seq_res {
                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, e) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, c) => Matched(__pos, { Extension::AvailabilityAttribute(c) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = {
                    let __seq_res = Matched(__pos, __pos);
                    match __seq_res {
                        Matched(__pos, l) => {
                            let __seq_res = __parse_attribute_name(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, e) => {
                                    let __seq_res = Matched(__pos, __pos);
                                    match __seq_res {
                                        Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, n) => {
                        let __seq_res = __parse__(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = match __parse_attribute_parameters(__input, __state, __pos, env) {
                                    Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                    Failed => Matched(__pos, None),
                                };
                                match __seq_res {
                                    Matched(__pos, p) => Matched(__pos, { Extension::Attribute(Attribute { name: n, arguments: p.unwrap_or_default() }) }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_attribute_name<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<String> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let str_start = __pos;
            match {
                __state.suppress_fail += 1;
                let res = {
                    let __seq_res = if __input.len() > __pos {
                        let (__ch, __next) = char_range_at(__input, __pos);
                        match __ch {
                            '_' | 'a'...'z' | 'A'...'Z' => Matched(__next, ()),
                            _ => __state.mark_failure(__pos, "[_a-zA-Z]"),
                        }
                    } else {
                        __state.mark_failure(__pos, "[_a-zA-Z]")
                    };
                    match __seq_res {
                        Matched(__pos, _) => {
                            let mut __repeat_pos = __pos;
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = if __input.len() > __pos {
                                    let (__ch, __next) = char_range_at(__input, __pos);
                                    match __ch {
                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                    }
                                } else {
                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                };
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            Matched(__repeat_pos, ())
                        }
                        Failed => Failed,
                    }
                };
                __state.suppress_fail -= 1;
                res
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, n) => Matched(__pos, { String::from(n) }),
            Failed => Failed,
        }
    }
}

fn __parse_attribute_parameters<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Vec<Node<Expression<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "(");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let __seq_res = {
                                let mut __repeat_pos = __pos;
                                let mut __repeat_value = vec![];
                                loop {
                                    let __pos = __repeat_pos;
                                    let __pos = if __repeat_value.len() > 0 {
                                        let __sep_res = {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = slice_eq(__input, __state, __pos, ",");
                                                    match __seq_res {
                                                        Matched(__pos, _) => __parse__(__input, __state, __pos, env),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        };
                                        match __sep_res {
                                            Matched(__newpos, _) => __newpos,
                                            Failed => break,
                                        }
                                    } else {
                                        __pos
                                    };
                                    let __step_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = __parse_assignment_expression0(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                            __repeat_value.push(__value);
                                        }
                                        Failed => {
                                            break;
                                        }
                                    }
                                }
                                Matched(__repeat_pos, __repeat_value)
                            };
                            match __seq_res {
                                Matched(__pos, e) => Matched(__pos, { e }),
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, e) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                        match __seq_res {
                                            Matched(__pos, _) => Matched(__pos, { e }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_attr_availability<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<AvailabilityAttribute<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let res = {
                let __seq_res = slice_eq(__input, __state, __pos, "availability");
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                            };
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Failed => Matched(__pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "(");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = __parse_identifier(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, p) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = slice_eq(__input, __state, __pos, ",");
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, _) => {
                                                                        let __seq_res = {
                                                                            let __seq_res = {
                                                                                let mut __repeat_pos = __pos;
                                                                                let mut __repeat_value = vec![];
                                                                                loop {
                                                                                    let __pos = __repeat_pos;
                                                                                    let __pos = if __repeat_value.len() > 0 {
                                                                                        let __sep_res = {
                                                                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                            match __seq_res {
                                                                                                Matched(__pos, _) => {
                                                                                                    let __seq_res = slice_eq(__input, __state, __pos, ",");
                                                                                                    match __seq_res {
                                                                                                        Matched(__pos, _) => __parse__(__input, __state, __pos, env),
                                                                                                        Failed => Failed,
                                                                                                    }
                                                                                                }
                                                                                                Failed => Failed,
                                                                                            }
                                                                                        };
                                                                                        match __sep_res {
                                                                                            Matched(__newpos, _) => __newpos,
                                                                                            Failed => break,
                                                                                        }
                                                                                    } else {
                                                                                        __pos
                                                                                    };
                                                                                    let __step_res = {
                                                                                        let __seq_res = Matched(__pos, __pos);
                                                                                        match __seq_res {
                                                                                            Matched(__pos, l) => {
                                                                                                let __seq_res = __parse_attr_availability_clause(__input, __state, __pos, env);
                                                                                                match __seq_res {
                                                                                                    Matched(__pos, e) => {
                                                                                                        let __seq_res = Matched(__pos, __pos);
                                                                                                        match __seq_res {
                                                                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                                                            Failed => Failed,
                                                                                                        }
                                                                                                    }
                                                                                                    Failed => Failed,
                                                                                                }
                                                                                            }
                                                                                            Failed => Failed,
                                                                                        }
                                                                                    };
                                                                                    match __step_res {
                                                                                        Matched(__newpos, __value) => {
                                                                                            __repeat_pos = __newpos;
                                                                                            __repeat_value.push(__value);
                                                                                        }
                                                                                        Failed => {
                                                                                            break;
                                                                                        }
                                                                                    }
                                                                                }
                                                                                if __repeat_value.len() >= 1 {
                                                                                    Matched(__repeat_pos, __repeat_value)
                                                                                } else {
                                                                                    Failed
                                                                                }
                                                                            };
                                                                            match __seq_res {
                                                                                Matched(__pos, e) => Matched(__pos, { e }),
                                                                                Failed => Failed,
                                                                            }
                                                                        };
                                                                        match __seq_res {
                                                                            Matched(__pos, c) => {
                                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                match __seq_res {
                                                                                    Matched(__pos, _) => {
                                                                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                                                        match __seq_res {
                                                                                            Matched(__pos, _) => Matched(__pos, { AvailabilityAttribute { platform: p, clauses: c } }),
                                                                                            Failed => Failed,
                                                                                        }
                                                                                    }
                                                                                    Failed => Failed,
                                                                                }
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_attr_availability_clause<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<AvailabilityClause> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                __state.suppress_fail += 1;
                let res = {
                    let __seq_res = slice_eq(__input, __state, __pos, "introduced");
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let __assert_res = if __input.len() > __pos {
                                    let (__ch, __next) = char_range_at(__input, __pos);
                                    match __ch {
                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                    }
                                } else {
                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                };
                                __state.suppress_fail -= 1;
                                match __assert_res {
                                    Failed => Matched(__pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { e }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                __state.suppress_fail -= 1;
                res
            };
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = slice_eq(__input, __state, __pos, "=");
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = {
                                                let __seq_res = Matched(__pos, __pos);
                                                match __seq_res {
                                                    Matched(__pos, l) => {
                                                        let __seq_res = __parse_attr_availability_version(__input, __state, __pos, env);
                                                        match __seq_res {
                                                            Matched(__pos, e) => {
                                                                let __seq_res = Matched(__pos, __pos);
                                                                match __seq_res {
                                                                    Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, v) => Matched(__pos, { AvailabilityClause::Introduced(v) }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = {
                        __state.suppress_fail += 1;
                        let res = {
                            let __seq_res = slice_eq(__input, __state, __pos, "deprecated");
                            match __seq_res {
                                Matched(__pos, e) => {
                                    let __seq_res = {
                                        __state.suppress_fail += 1;
                                        let __assert_res = if __input.len() > __pos {
                                            let (__ch, __next) = char_range_at(__input, __pos);
                                            match __ch {
                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                            }
                                        } else {
                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                        };
                                        __state.suppress_fail -= 1;
                                        match __assert_res {
                                            Failed => Matched(__pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, { e }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        __state.suppress_fail -= 1;
                        res
                    };
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = slice_eq(__input, __state, __pos, "=");
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, l) => {
                                                                let __seq_res = __parse_attr_availability_version(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, e) => {
                                                                        let __seq_res = Matched(__pos, __pos);
                                                                        match __seq_res {
                                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    };
                                                    match __seq_res {
                                                        Matched(__pos, v) => Matched(__pos, { AvailabilityClause::Deprecated(v) }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let res = {
                                    let __seq_res = slice_eq(__input, __state, __pos, "obsoleted");
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = {
                                                __state.suppress_fail += 1;
                                                let __assert_res = if __input.len() > __pos {
                                                    let (__ch, __next) = char_range_at(__input, __pos);
                                                    match __ch {
                                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                    }
                                                } else {
                                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                };
                                                __state.suppress_fail -= 1;
                                                match __assert_res {
                                                    Failed => Matched(__pos, ()),
                                                    Matched(..) => Failed,
                                                }
                                            };
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { e }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                __state.suppress_fail -= 1;
                                res
                            };
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = slice_eq(__input, __state, __pos, "=");
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                                    match __seq_res {
                                                        Matched(__pos, _) => {
                                                            let __seq_res = {
                                                                let __seq_res = Matched(__pos, __pos);
                                                                match __seq_res {
                                                                    Matched(__pos, l) => {
                                                                        let __seq_res = __parse_attr_availability_version(__input, __state, __pos, env);
                                                                        match __seq_res {
                                                                            Matched(__pos, e) => {
                                                                                let __seq_res = Matched(__pos, __pos);
                                                                                match __seq_res {
                                                                                    Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                                    Failed => Failed,
                                                                                }
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            };
                                                            match __seq_res {
                                                                Matched(__pos, v) => Matched(__pos, { AvailabilityClause::Obsoleted(v) }),
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = {
                                    let __seq_res = {
                                        __state.suppress_fail += 1;
                                        let res = {
                                            let __seq_res = slice_eq(__input, __state, __pos, "unavailable");
                                            match __seq_res {
                                                Matched(__pos, e) => {
                                                    let __seq_res = {
                                                        __state.suppress_fail += 1;
                                                        let __assert_res = if __input.len() > __pos {
                                                            let (__ch, __next) = char_range_at(__input, __pos);
                                                            match __ch {
                                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                            }
                                                        } else {
                                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                        };
                                                        __state.suppress_fail -= 1;
                                                        match __assert_res {
                                                            Failed => Matched(__pos, ()),
                                                            Matched(..) => Failed,
                                                        }
                                                    };
                                                    match __seq_res {
                                                        Matched(__pos, _) => Matched(__pos, { e }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        };
                                        __state.suppress_fail -= 1;
                                        res
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, { AvailabilityClause::Unavailable }),
                                        Failed => Failed,
                                    }
                                };
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __choice_res = {
                                            let __seq_res = {
                                                __state.suppress_fail += 1;
                                                let res = {
                                                    let __seq_res = slice_eq(__input, __state, __pos, "message");
                                                    match __seq_res {
                                                        Matched(__pos, e) => {
                                                            let __seq_res = {
                                                                __state.suppress_fail += 1;
                                                                let __assert_res = if __input.len() > __pos {
                                                                    let (__ch, __next) = char_range_at(__input, __pos);
                                                                    match __ch {
                                                                        '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                        _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                                    }
                                                                } else {
                                                                    __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                                };
                                                                __state.suppress_fail -= 1;
                                                                match __assert_res {
                                                                    Failed => Matched(__pos, ()),
                                                                    Matched(..) => Failed,
                                                                }
                                                            };
                                                            match __seq_res {
                                                                Matched(__pos, _) => Matched(__pos, { e }),
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                };
                                                __state.suppress_fail -= 1;
                                                res
                                            };
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                                    match __seq_res {
                                                        Matched(__pos, _) => {
                                                            let __seq_res = slice_eq(__input, __state, __pos, "=");
                                                            match __seq_res {
                                                                Matched(__pos, _) => {
                                                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                                                    match __seq_res {
                                                                        Matched(__pos, _) => {
                                                                            let __seq_res = __parse_string_literal(__input, __state, __pos, env);
                                                                            match __seq_res {
                                                                                Matched(__pos, s) => Matched(__pos, { AvailabilityClause::Message(s) }),
                                                                                Failed => Failed,
                                                                            }
                                                                        }
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        };
                                        match __choice_res {
                                            Matched(__pos, __value) => Matched(__pos, __value),
                                            Failed => {
                                                let __seq_res = {
                                                    __state.suppress_fail += 1;
                                                    let res = {
                                                        let __seq_res = slice_eq(__input, __state, __pos, "replacement");
                                                        match __seq_res {
                                                            Matched(__pos, e) => {
                                                                let __seq_res = {
                                                                    __state.suppress_fail += 1;
                                                                    let __assert_res = if __input.len() > __pos {
                                                                        let (__ch, __next) = char_range_at(__input, __pos);
                                                                        match __ch {
                                                                            '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                                            _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                                                        }
                                                                    } else {
                                                                        __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                                                    };
                                                                    __state.suppress_fail -= 1;
                                                                    match __assert_res {
                                                                        Failed => Matched(__pos, ()),
                                                                        Matched(..) => Failed,
                                                                    }
                                                                };
                                                                match __seq_res {
                                                                    Matched(__pos, _) => Matched(__pos, { e }),
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    };
                                                    __state.suppress_fail -= 1;
                                                    res
                                                };
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = slice_eq(__input, __state, __pos, "=");
                                                                match __seq_res {
                                                                    Matched(__pos, _) => {
                                                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                                                        match __seq_res {
                                                                            Matched(__pos, _) => {
                                                                                let __seq_res = __parse_string_literal(__input, __state, __pos, env);
                                                                                match __seq_res {
                                                                                    Matched(__pos, s) => Matched(__pos, { AvailabilityClause::Replacement(s) }),
                                                                                    Failed => Failed,
                                                                                }
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_attr_availability_version<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<AvailabilityVersion> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let str_start = __pos;
            match {
                let mut __repeat_pos = __pos;
                let mut __repeat_value = vec![];
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = __parse_dec(__input, __state, __pos, env);
                    match __step_res {
                        Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                            __repeat_value.push(__value);
                        }
                        Failed => {
                            break;
                        }
                    }
                }
                if __repeat_value.len() >= 1 {
                    Matched(__repeat_pos, ())
                } else {
                    Failed
                }
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, a) => {
                let __seq_res = match {
                    let __seq_res = slice_eq(__input, __state, __pos, ".");
                    match __seq_res {
                        Matched(__pos, _) => {
                            let str_start = __pos;
                            match {
                                let mut __repeat_pos = __pos;
                                let mut __repeat_value = vec![];
                                loop {
                                    let __pos = __repeat_pos;
                                    let __step_res = __parse_dec(__input, __state, __pos, env);
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                            __repeat_value.push(__value);
                                        }
                                        Failed => {
                                            break;
                                        }
                                    }
                                }
                                if __repeat_value.len() >= 1 {
                                    Matched(__repeat_pos, ())
                                } else {
                                    Failed
                                }
                            } {
                                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                } {
                    Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                    Failed => Matched(__pos, None),
                };
                match __seq_res {
                    Matched(__pos, b) => {
                        let __seq_res = match {
                            let __seq_res = slice_eq(__input, __state, __pos, ".");
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let str_start = __pos;
                                    match {
                                        let mut __repeat_pos = __pos;
                                        let mut __repeat_value = vec![];
                                        loop {
                                            let __pos = __repeat_pos;
                                            let __step_res = __parse_dec(__input, __state, __pos, env);
                                            match __step_res {
                                                Matched(__newpos, __value) => {
                                                    __repeat_pos = __newpos;
                                                    __repeat_value.push(__value);
                                                }
                                                Failed => {
                                                    break;
                                                }
                                            }
                                        }
                                        if __repeat_value.len() >= 1 {
                                            Matched(__repeat_pos, ())
                                        } else {
                                            Failed
                                        }
                                    } {
                                        Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        } {
                            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                            Failed => Matched(__pos, None),
                        };
                        match __seq_res {
                            Matched(__pos, c) => Matched(__pos, { AvailabilityVersion { major: a.into(), minor: b.map(str::to_owned), subminor: c.map(str::to_owned) } }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_asm_label<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Node<Extension<T::Interned>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = Matched(__pos, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse_asm_label0(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = Matched(__pos, __pos);
                        match __seq_res {
                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_asm_label0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Extension<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_asm_label_keyword(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "(");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = __parse_string_literal(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, s) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                        match __seq_res {
                                                            Matched(__pos, _) => Matched(__pos, { Extension::AsmLabel(s) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_asm_label_keyword<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            __state.suppress_fail += 1;
            let res = {
                let __choice_res = {
                    __state.suppress_fail += 1;
                    let res = {
                        let __seq_res = slice_eq(__input, __state, __pos, "asm");
                        match __seq_res {
                            Matched(__pos, e) => {
                                let __seq_res = {
                                    __state.suppress_fail += 1;
                                    let __assert_res = if __input.len() > __pos {
                                        let (__ch, __next) = char_range_at(__input, __pos);
                                        match __ch {
                                            '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                            _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                        }
                                    } else {
                                        __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                    };
                                    __state.suppress_fail -= 1;
                                    match __assert_res {
                                        Failed => Matched(__pos, ()),
                                        Matched(..) => Failed,
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, _) => Matched(__pos, { e }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    };
                    __state.suppress_fail -= 1;
                    res
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        __state.suppress_fail += 1;
                        let res = {
                            let __seq_res = {
                                let __seq_res = slice_eq(__input, __state, __pos, "__asm");
                                match __seq_res {
                                    Matched(__pos, _) => match slice_eq(__input, __state, __pos, "__") {
                                        Matched(__newpos, _) => Matched(__newpos, ()),
                                        Failed => Matched(__pos, ()),
                                    },
                                    Failed => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, e) => {
                                    let __seq_res = {
                                        __state.suppress_fail += 1;
                                        let __assert_res = if __input.len() > __pos {
                                            let (__ch, __next) = char_range_at(__input, __pos);
                                            match __ch {
                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                            }
                                        } else {
                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                        };
                                        __state.suppress_fail -= 1;
                                        match __assert_res {
                                            Failed => Matched(__pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, { e }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        __state.suppress_fail -= 1;
                        res
                    }
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                __state.mark_failure(__pos, "asm");
                Failed
            }
        }
    }
}

fn __parse_asm_statement<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Statement<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_asm_statement0(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, s) => Matched(__pos, { Statement::Asm(s) }),
            Failed => Failed,
        }
    }
}

fn __parse_asm_statement0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<AsmStatement<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let res = {
                let __seq_res = {
                    let __choice_res = slice_eq(__input, __state, __pos, "asm");
                    match __choice_res {
                        Matched(__pos, __value) => Matched(__pos, __value),
                        Failed => {
                            let __seq_res = slice_eq(__input, __state, __pos, "__asm");
                            match __seq_res {
                                Matched(__pos, _) => match slice_eq(__input, __state, __pos, "__") {
                                    Matched(__newpos, _) => Matched(__newpos, ()),
                                    Failed => Matched(__pos, ()),
                                },
                                Failed => Failed,
                            }
                        }
                    }
                };
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                            };
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Failed => Matched(__pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = match __parse_type_qualifier(__input, __state, __pos, env) {
                            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                            Failed => Matched(__pos, None),
                        };
                        match __seq_res {
                            Matched(__pos, q) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = slice_eq(__input, __state, __pos, "(");
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = __parse_string_literal(__input, __state, __pos, env);
                                                        match __seq_res {
                                                            Matched(__pos, a) => {
                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, _) => {
                                                                        let __seq_res = match {
                                                                            let __seq_res = slice_eq(__input, __state, __pos, ":");
                                                                            match __seq_res {
                                                                                Matched(__pos, _) => {
                                                                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                    match __seq_res {
                                                                                        Matched(__pos, _) => {
                                                                                            let __seq_res = __parse_asm_operand_list(__input, __state, __pos, env);
                                                                                            match __seq_res {
                                                                                                Matched(__pos, e) => {
                                                                                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                                    match __seq_res {
                                                                                                        Matched(__pos, _) => {
                                                                                                            let __seq_res = match {
                                                                                                                let __seq_res = slice_eq(__input, __state, __pos, ":");
                                                                                                                match __seq_res {
                                                                                                                    Matched(__pos, _) => {
                                                                                                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                                                        match __seq_res {
                                                                                                                            Matched(__pos, _) => {
                                                                                                                                let __seq_res = __parse_asm_operand_list(__input, __state, __pos, env);
                                                                                                                                match __seq_res {
                                                                                                                                    Matched(__pos, e) => {
                                                                                                                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                                                                        match __seq_res {
                                                                                                                                            Matched(__pos, _) => {
                                                                                                                                                let __seq_res = match {
                                                                                                                                                    let __seq_res = slice_eq(__input, __state, __pos, ":");
                                                                                                                                                    match __seq_res {
                                                                                                                                                        Matched(__pos, _) => {
                                                                                                                                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                                                                                            match __seq_res {
                                                                                                                                                                Matched(__pos, _) => {
                                                                                                                                                                    let __seq_res = {
                                                                                                                                                                        let __seq_res = {
                                                                                                                                                                            let mut __repeat_pos = __pos;
                                                                                                                                                                            let mut __repeat_value = vec![];
                                                                                                                                                                            loop {
                                                                                                                                                                                let __pos = __repeat_pos;
                                                                                                                                                                                let __pos = if __repeat_value.len() > 0 {
                                                                                                                                                                                    let __sep_res = {
                                                                                                                                                                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                                                                                                                        match __seq_res {
                                                                                                                                                                                            Matched(__pos, _) => {
                                                                                                                                                                                                let __seq_res = slice_eq(__input, __state, __pos, ",");
                                                                                                                                                                                                match __seq_res {
                                                                                                                                                                                                    Matched(__pos, _) => __parse__(__input, __state, __pos, env),
                                                                                                                                                                                                    Failed => Failed,
                                                                                                                                                                                                }
                                                                                                                                                                                            }
                                                                                                                                                                                            Failed => Failed,
                                                                                                                                                                                        }
                                                                                                                                                                                    };
                                                                                                                                                                                    match __sep_res {
                                                                                                                                                                                        Matched(__newpos, _) => __newpos,
                                                                                                                                                                                        Failed => break,
                                                                                                                                                                                    }
                                                                                                                                                                                } else {
                                                                                                                                                                                    __pos
                                                                                                                                                                                };
                                                                                                                                                                                let __step_res = __parse_string_literal(__input, __state, __pos, env);
                                                                                                                                                                                match __step_res {
                                                                                                                                                                                    Matched(__newpos, __value) => {
                                                                                                                                                                                        __repeat_pos = __newpos;
                                                                                                                                                                                        __repeat_value.push(__value);
                                                                                                                                                                                    }
                                                                                                                                                                                    Failed => {
                                                                                                                                                                                        break;
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                            Matched(__repeat_pos, __repeat_value)
                                                                                                                                                                        };
                                                                                                                                                                        match __seq_res {
                                                                                                                                                                            Matched(__pos, e) => Matched(__pos, { e }),
                                                                                                                                                                            Failed => Failed,
                                                                                                                                                                        }
                                                                                                                                                                    };
                                                                                                                                                                    match __seq_res {
                                                                                                                                                                        Matched(__pos, e) => {
                                                                                                                                                                            let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                                                                                                            match __seq_res {
                                                                                                                                                                                Matched(__pos, _) => {
                                                                                                                                                                                    let __seq_res = match Matched(__pos, ()) {
                                                                                                                                                                                        Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                                                                                                                                                                        Failed => Matched(__pos, None),
                                                                                                                                                                                    };
                                                                                                                                                                                    match __seq_res {
                                                                                                                                                                                        Matched(__pos, t) => Matched(__pos, { (e, t.unwrap_or_default()) }),
                                                                                                                                                                                        Failed => Failed,
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                                Failed => Failed,
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                        Failed => Failed,
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                                Failed => Failed,
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                        Failed => Failed,
                                                                                                                                                    }
                                                                                                                                                } {
                                                                                                                                                    Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                                                                                                                                    Failed => Matched(__pos, None),
                                                                                                                                                };
                                                                                                                                                match __seq_res {
                                                                                                                                                    Matched(__pos, t) => Matched(__pos, { (e, t.unwrap_or_default()) }),
                                                                                                                                                    Failed => Failed,
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                            Failed => Failed,
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                    Failed => Failed,
                                                                                                                                }
                                                                                                                            }
                                                                                                                            Failed => Failed,
                                                                                                                        }
                                                                                                                    }
                                                                                                                    Failed => Failed,
                                                                                                                }
                                                                                                            } {
                                                                                                                Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                                                                                                Failed => Matched(__pos, None),
                                                                                                            };
                                                                                                            match __seq_res {
                                                                                                                Matched(__pos, t) => Matched(__pos, { (e, t.unwrap_or_default()) }),
                                                                                                                Failed => Failed,
                                                                                                            }
                                                                                                        }
                                                                                                        Failed => Failed,
                                                                                                    }
                                                                                                }
                                                                                                Failed => Failed,
                                                                                            }
                                                                                        }
                                                                                        Failed => Failed,
                                                                                    }
                                                                                }
                                                                                Failed => Failed,
                                                                            }
                                                                        } {
                                                                            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                                                            Failed => Matched(__pos, None),
                                                                        };
                                                                        match __seq_res {
                                                                            Matched(__pos, o) => {
                                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                match __seq_res {
                                                                                    Matched(__pos, _) => {
                                                                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                                                        match __seq_res {
                                                                                            Matched(__pos, _) => {
                                                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                                match __seq_res {
                                                                                                    Matched(__pos, _) => {
                                                                                                        let __seq_res = slice_eq(__input, __state, __pos, ";");
                                                                                                        match __seq_res {
                                                                                                            Matched(__pos, _) => Matched(__pos, {
                                                                                                                if let Some((o, (i, (c, ())))) = o {
                                                                                                                    AsmStatement::GnuExtended(GnuExtendedAsmStatement { qualifier: q, template: a, outputs: o, inputs: i, clobbers: c })
                                                                                                                } else {
                                                                                                                    AsmStatement::GnuBasic(a)
                                                                                                                }
                                                                                                            }),
                                                                                                            Failed => Failed,
                                                                                                        }
                                                                                                    }
                                                                                                    Failed => Failed,
                                                                                                }
                                                                                            }
                                                                                            Failed => Failed,
                                                                                        }
                                                                                    }
                                                                                    Failed => Failed,
                                                                                }
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_asm_operand_list<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Vec<Node<GnuAsmOperand<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let mut __repeat_pos = __pos;
            let mut __repeat_value = vec![];
            loop {
                let __pos = __repeat_pos;
                let __pos = if __repeat_value.len() > 0 {
                    let __sep_res = {
                        let __seq_res = __parse__(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = slice_eq(__input, __state, __pos, ",");
                                match __seq_res {
                                    Matched(__pos, _) => __parse__(__input, __state, __pos, env),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    };
                    match __sep_res {
                        Matched(__newpos, _) => __newpos,
                        Failed => break,
                    }
                } else {
                    __pos
                };
                let __step_res = {
                    let __seq_res = Matched(__pos, __pos);
                    match __seq_res {
                        Matched(__pos, l) => {
                            let __seq_res = __parse_asm_operand(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, e) => {
                                    let __seq_res = Matched(__pos, __pos);
                                    match __seq_res {
                                        Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __step_res {
                    Matched(__newpos, __value) => {
                        __repeat_pos = __newpos;
                        __repeat_value.push(__value);
                    }
                    Failed => {
                        break;
                    }
                }
            }
            Matched(__repeat_pos, __repeat_value)
        };
        match __seq_res {
            Matched(__pos, e) => Matched(__pos, { e }),
            Failed => Failed,
        }
    }
}

fn __parse_asm_operand<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<GnuAsmOperand<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = match {
            let __seq_res = slice_eq(__input, __state, __pos, "[");
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = __parse_identifier(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, i) => {
                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = slice_eq(__input, __state, __pos, "]");
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = __parse__(__input, __state, __pos, env);
                                                    match __seq_res {
                                                        Matched(__pos, _) => Matched(__pos, { i }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        } {
            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
            Failed => Matched(__pos, None),
        };
        match __seq_res {
            Matched(__pos, i) => {
                let __seq_res = __parse_string_literal(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, s) => {
                        let __seq_res = __parse__(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = slice_eq(__input, __state, __pos, "(");
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = {
                                                    let __seq_res = Matched(__pos, __pos);
                                                    match __seq_res {
                                                        Matched(__pos, l) => {
                                                            let __seq_res = __parse_expression0(__input, __state, __pos, env);
                                                            match __seq_res {
                                                                Matched(__pos, e) => {
                                                                    let __seq_res = Matched(__pos, __pos);
                                                                    match __seq_res {
                                                                        Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                        Failed => Failed,
                                                                    }
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                };
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = __parse__(__input, __state, __pos, env);
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                                match __seq_res {
                                                                    Matched(__pos, _) => Matched(__pos, { GnuAsmOperand { symbolic_name: i, constraints: s, variable_name: e } }),
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_gnu_primary_expression<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Expression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = __parse_statement_expression(__input, __state, __pos, env);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = __parse_offsetof_expression(__input, __state, __pos, env);
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = __parse_va_arg_expression(__input, __state, __pos, env);
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => __parse_keyword_expression(__input, __state, __pos, env),
                        }
                    }
                }
            }
        }
    }
}

fn __parse_statement_expression<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Expression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "(");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let __seq_res = Matched(__pos, {
                                env.enter_scope();
                            });
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = match {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = __parse_compound_statement(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    } {
                                        Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                        Failed => Matched(__pos, None),
                                    };
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            match {
                                                env.leave_scope();
                                                e.ok_or("")
                                            } {
                                                Ok(res) => Matched(__pos, res),
                                                Err(expected) => {
                                                    __state.mark_failure(__pos, expected);
                                                    Failed
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, s) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                        match __seq_res {
                                            Matched(__pos, _) => Matched(__pos, { Expression::Statement(Box::new(s)) }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_va_arg_expression<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Expression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_va_arg_expression_inner(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, n) => Matched(__pos, { Expression::VaArg(Box::new(n)) }),
            Failed => Failed,
        }
    }
}

fn __parse_va_arg_expression_inner<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<VaArgExpression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let res = {
                let __seq_res = slice_eq(__input, __state, __pos, "__builtin_va_arg");
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                            };
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Failed => Matched(__pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "(");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = __parse_assignment_expression(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, e) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = slice_eq(__input, __state, __pos, ",");
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, _) => {
                                                                        let __seq_res = __parse_type_name(__input, __state, __pos, env);
                                                                        match __seq_res {
                                                                            Matched(__pos, t) => {
                                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                match __seq_res {
                                                                                    Matched(__pos, _) => {
                                                                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                                                        match __seq_res {
                                                                                            Matched(__pos, _) => Matched(__pos, { VaArgExpression { va_list: e, type_name: t } }),
                                                                                            Failed => Failed,
                                                                                        }
                                                                                    }
                                                                                    Failed => Failed,
                                                                                }
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_keyword_expression<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Expression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = {
                        let str_start = __pos;
                        match __parse_keyword_expression0(__input, __state, __pos, env) {
                            Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                            Failed => Failed,
                        }
                    };
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, k) => Matched(__pos, {
                let ident = Identifier { name: env.interner.intern_str(k.node) };
                Expression::Identifier(Box::new(Node::new(ident, k.span)))
            }),
            Failed => Failed,
        }
    }
}

fn __parse_keyword_expression0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            __state.suppress_fail += 1;
            let res = {
                let __seq_res = slice_eq(__input, __state, __pos, "__func__");
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                            };
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Failed => Matched(__pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    __state.suppress_fail += 1;
                    let res = {
                        let __seq_res = slice_eq(__input, __state, __pos, "__FUNCTION__");
                        match __seq_res {
                            Matched(__pos, e) => {
                                let __seq_res = {
                                    __state.suppress_fail += 1;
                                    let __assert_res = if __input.len() > __pos {
                                        let (__ch, __next) = char_range_at(__input, __pos);
                                        match __ch {
                                            '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                            _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                        }
                                    } else {
                                        __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                    };
                                    __state.suppress_fail -= 1;
                                    match __assert_res {
                                        Failed => Matched(__pos, ()),
                                        Matched(..) => Failed,
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, _) => Matched(__pos, { e }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    };
                    __state.suppress_fail -= 1;
                    res
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        __state.suppress_fail += 1;
                        let res = {
                            let __seq_res = slice_eq(__input, __state, __pos, "__PRETTY_FUNCTION__");
                            match __seq_res {
                                Matched(__pos, e) => {
                                    let __seq_res = {
                                        __state.suppress_fail += 1;
                                        let __assert_res = if __input.len() > __pos {
                                            let (__ch, __next) = char_range_at(__input, __pos);
                                            match __ch {
                                                '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                                _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                            }
                                        } else {
                                            __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                                        };
                                        __state.suppress_fail -= 1;
                                        match __assert_res {
                                            Failed => Matched(__pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, { e }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        __state.suppress_fail -= 1;
                        res
                    }
                }
            }
        }
    }
}

fn __parse_offsetof_expression<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<Expression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __seq_res = Matched(__pos, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse_offsetof_expression_inner(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, e) => {
                            let __seq_res = Matched(__pos, __pos);
                            match __seq_res {
                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, n) => Matched(__pos, { Expression::OffsetOf(Box::new(n)) }),
            Failed => Failed,
        }
    }
}

fn __parse_offsetof_expression_inner<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<OffsetOfExpression<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let res = {
                let __seq_res = slice_eq(__input, __state, __pos, "__builtin_offsetof");
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                            };
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Failed => Matched(__pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "(");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = __parse_type_name(__input, __state, __pos, env);
                                        match __seq_res {
                                            Matched(__pos, t) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = slice_eq(__input, __state, __pos, ",");
                                                        match __seq_res {
                                                            Matched(__pos, _) => {
                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                match __seq_res {
                                                                    Matched(__pos, _) => {
                                                                        let __seq_res = {
                                                                            let __seq_res = Matched(__pos, __pos);
                                                                            match __seq_res {
                                                                                Matched(__pos, l) => {
                                                                                    let __seq_res = __parse_offsetof_designator(__input, __state, __pos, env);
                                                                                    match __seq_res {
                                                                                        Matched(__pos, e) => {
                                                                                            let __seq_res = Matched(__pos, __pos);
                                                                                            match __seq_res {
                                                                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                                                Failed => Failed,
                                                                                            }
                                                                                        }
                                                                                        Failed => Failed,
                                                                                    }
                                                                                }
                                                                                Failed => Failed,
                                                                            }
                                                                        };
                                                                        match __seq_res {
                                                                            Matched(__pos, d) => {
                                                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                                                match __seq_res {
                                                                                    Matched(__pos, _) => {
                                                                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                                                        match __seq_res {
                                                                                            Matched(__pos, _) => Matched(__pos, { OffsetOfExpression { type_name: t, designator: d } }),
                                                                                            Failed => Failed,
                                                                                        }
                                                                                    }
                                                                                    Failed => Failed,
                                                                                }
                                                                            }
                                                                            Failed => Failed,
                                                                        }
                                                                    }
                                                                    Failed => Failed,
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_offsetof_designator<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<OffsetDesignator<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_identifier(__input, __state, __pos, env);
        match __seq_res {
            Matched(__pos, i) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let __seq_res = {
                                let mut __repeat_pos = __pos;
                                let mut __repeat_value = vec![];
                                loop {
                                    let __pos = __repeat_pos;
                                    let __pos = if __repeat_value.len() > 0 {
                                        let __sep_res = __parse__(__input, __state, __pos, env);
                                        match __sep_res {
                                            Matched(__newpos, _) => __newpos,
                                            Failed => break,
                                        }
                                    } else {
                                        __pos
                                    };
                                    let __step_res = {
                                        let __seq_res = Matched(__pos, __pos);
                                        match __seq_res {
                                            Matched(__pos, l) => {
                                                let __seq_res = __parse_offsetof_member(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, e) => {
                                                        let __seq_res = Matched(__pos, __pos);
                                                        match __seq_res {
                                                            Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                            __repeat_value.push(__value);
                                        }
                                        Failed => {
                                            break;
                                        }
                                    }
                                }
                                Matched(__repeat_pos, __repeat_value)
                            };
                            match __seq_res {
                                Matched(__pos, e) => Matched(__pos, { e }),
                                Failed => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, d) => Matched(__pos, { OffsetDesignator { base: i, members: d } }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_offsetof_member<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<OffsetMember<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, ".");
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = __parse__(__input, __state, __pos, env);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = __parse_identifier(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, i) => Matched(__pos, { OffsetMember::Member(i) }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = slice_eq(__input, __state, __pos, "->");
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = __parse__(__input, __state, __pos, env);
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = __parse_identifier(__input, __state, __pos, env);
                                    match __seq_res {
                                        Matched(__pos, i) => Matched(__pos, { OffsetMember::IndirectMember(i) }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __seq_res = slice_eq(__input, __state, __pos, "[");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = {
                                            let __seq_res = Matched(__pos, __pos);
                                            match __seq_res {
                                                Matched(__pos, l) => {
                                                    let __seq_res = __parse_expression0(__input, __state, __pos, env);
                                                    match __seq_res {
                                                        Matched(__pos, e) => {
                                                            let __seq_res = Matched(__pos, __pos);
                                                            match __seq_res {
                                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, e) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = slice_eq(__input, __state, __pos, "]");
                                                        match __seq_res {
                                                            Matched(__pos, _) => Matched(__pos, { OffsetMember::Index(e) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
            }
        }
    }
}

fn __parse_typeof_specifier<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<TypeSpecifier<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            __state.suppress_fail += 1;
            let res = {
                let __seq_res = {
                    let __choice_res = slice_eq(__input, __state, __pos, "typeof");
                    match __choice_res {
                        Matched(__pos, __value) => Matched(__pos, __value),
                        Failed => {
                            let __seq_res = slice_eq(__input, __state, __pos, "__typeof");
                            match __seq_res {
                                Matched(__pos, _) => match slice_eq(__input, __state, __pos, "__") {
                                    Matched(__newpos, _) => Matched(__newpos, ()),
                                    Failed => Matched(__pos, ()),
                                },
                                Failed => Failed,
                            }
                        }
                    }
                };
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '_' | 'a'...'z' | 'A'...'Z' | '0'...'9' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[_a-zA-Z0-9]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[_a-zA-Z0-9]")
                            };
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Failed => Matched(__pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { e }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            __state.suppress_fail -= 1;
            res
        };
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse__(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "(");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse__(__input, __state, __pos, env);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = {
                                            let __seq_res = Matched(__pos, __pos);
                                            match __seq_res {
                                                Matched(__pos, l) => {
                                                    let __seq_res = __parse_typeof_specifier0(__input, __state, __pos, env);
                                                    match __seq_res {
                                                        Matched(__pos, e) => {
                                                            let __seq_res = Matched(__pos, __pos);
                                                            match __seq_res {
                                                                Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, e) => {
                                                let __seq_res = __parse__(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                                        match __seq_res {
                                                            Matched(__pos, _) => Matched(__pos, { TypeSpecifier::TypeOf(e) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_typeof_specifier0<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<TypeOf<T::Interned>> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let __seq_res = Matched(__pos, __pos);
                match __seq_res {
                    Matched(__pos, l) => {
                        let __seq_res = __parse_expression0(__input, __state, __pos, env);
                        match __seq_res {
                            Matched(__pos, e) => {
                                let __seq_res = Matched(__pos, __pos);
                                match __seq_res {
                                    Matched(__pos, r) => Matched(__pos, { Node::new(e, Span::span(l, r)) }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            };
            match __seq_res {
                Matched(__pos, e) => Matched(__pos, { TypeOf::Expression(e) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = __parse_type_name(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, t) => Matched(__pos, { TypeOf::Type(t) }),
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_ts18661_float_type_specifier<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<TS18661FloatType> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = __parse_ts18661_binary_float(__input, __state, __pos, env);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => __parse_ts18661_decimal_float(__input, __state, __pos, env),
        }
    }
}

fn __parse_ts18661_binary_float<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<TS18661FloatType> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "_Float");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse_ts18661_binary_width(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, width) => {
                        let __seq_res = match slice_eq(__input, __state, __pos, "x") {
                            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                            Failed => Matched(__pos, None),
                        };
                        match __seq_res {
                            Matched(__pos, extended) => Matched(__pos, { ts18661_float(true, width, extended.is_some()) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_ts18661_binary_width<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<usize> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let str_start = __pos;
            match {
                let __choice_res = slice_eq(__input, __state, __pos, "16");
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = slice_eq(__input, __state, __pos, "32");
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = slice_eq(__input, __state, __pos, "64");
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => slice_eq(__input, __state, __pos, "128"),
                                }
                            }
                        }
                    }
                }
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, n) => Matched(__pos, { n.parse().unwrap() }),
            Failed => Failed,
        }
    }
}

fn __parse_ts18661_decimal_float<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<TS18661FloatType> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "_Decimal");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse_ts18661_decimal_width(__input, __state, __pos, env);
                match __seq_res {
                    Matched(__pos, width) => {
                        let __seq_res = match slice_eq(__input, __state, __pos, "x") {
                            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                            Failed => Matched(__pos, None),
                        };
                        match __seq_res {
                            Matched(__pos, extended) => Matched(__pos, { ts18661_float(false, width, extended.is_some()) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_ts18661_decimal_width<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<usize> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let str_start = __pos;
            match {
                let __choice_res = slice_eq(__input, __state, __pos, "32");
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = slice_eq(__input, __state, __pos, "64");
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => slice_eq(__input, __state, __pos, "128"),
                        }
                    }
                }
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, n) => Matched(__pos, { n.parse().unwrap() }),
            Failed => Failed,
        }
    }
}

fn __parse_ts18661_float_suffix<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<TS18661FloatType> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = {
                let __choice_res = slice_eq(__input, __state, __pos, "df");
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => slice_eq(__input, __state, __pos, "DF"),
                }
            };
            match __seq_res {
                Matched(__pos, _) => Matched(__pos, { ts18661_float(false, 32, false) }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = {
                        let __choice_res = slice_eq(__input, __state, __pos, "dd");
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => slice_eq(__input, __state, __pos, "DD"),
                        }
                    };
                    match __seq_res {
                        Matched(__pos, _) => Matched(__pos, { ts18661_float(false, 64, false) }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = {
                                let __choice_res = slice_eq(__input, __state, __pos, "dl");
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => slice_eq(__input, __state, __pos, "DL"),
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { ts18661_float(false, 128, false) }),
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = {
                                    let __seq_res = if __input.len() > __pos {
                                        let (__ch, __next) = char_range_at(__input, __pos);
                                        match __ch {
                                            'f' | 'F' => Matched(__next, ()),
                                            _ => __state.mark_failure(__pos, "[fF]"),
                                        }
                                    } else {
                                        __state.mark_failure(__pos, "[fF]")
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res = __parse_ts18661_binary_width(__input, __state, __pos, env);
                                            match __seq_res {
                                                Matched(__pos, width) => {
                                                    let __seq_res = match slice_eq(__input, __state, __pos, "x") {
                                                        Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                                        Failed => Matched(__pos, None),
                                                    };
                                                    match __seq_res {
                                                        Matched(__pos, extended) => Matched(__pos, { ts18661_float(true, width, extended.is_some()) }),
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __seq_res = if __input.len() > __pos {
                                            let (__ch, __next) = char_range_at(__input, __pos);
                                            match __ch {
                                                'd' | 'D' => Matched(__next, ()),
                                                _ => __state.mark_failure(__pos, "[dD]"),
                                            }
                                        } else {
                                            __state.mark_failure(__pos, "[dD]")
                                        };
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res = __parse_ts18661_decimal_width(__input, __state, __pos, env);
                                                match __seq_res {
                                                    Matched(__pos, width) => {
                                                        let __seq_res = match slice_eq(__input, __state, __pos, "x") {
                                                            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                                                            Failed => Matched(__pos, None),
                                                        };
                                                        match __seq_res {
                                                            Matched(__pos, extended) => Matched(__pos, { ts18661_float(false, width, extended.is_some()) }),
                                                            Failed => Failed,
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_clang_guard<'input, T: Interner>(__input: &'input str, __state: &mut ParseState<'input, T>, __pos: usize, env: &mut Env<T>) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    match {
        if env.extensions_clang {
            Ok(())
        } else {
            Err("clang extensions disabled")
        }
    } {
        Ok(res) => Matched(__pos, res),
        Err(expected) => {
            __state.mark_failure(__pos, expected);
            Failed
        }
    }
}

pub fn constant<'input, T: Interner>(__input: &'input str, env: &mut Env<T>) -> ParseResult<Constant> {
    #![allow(non_snake_case, unused)]
    let mut __state = ParseState::new();
    match __parse_constant(__input, &mut __state, 0, env) {
        Matched(__pos, __value) => {
            if __pos == __input.len() {
                return Ok(__value);
            }
        }
        _ => {}
    }
    let (__line, __col) = pos_to_line(__input, __state.max_err_pos);
    Err(ParseError { line: __line, column: __col, offset: __state.max_err_pos, expected: __state.expected })
}

pub fn string_literal<'input, T: Interner>(__input: &'input str, env: &mut Env<T>) -> ParseResult<Node<Vec<String>>> {
    #![allow(non_snake_case, unused)]
    let mut __state = ParseState::new();
    match __parse_string_literal(__input, &mut __state, 0, env) {
        Matched(__pos, __value) => {
            if __pos == __input.len() {
                return Ok(__value);
            }
        }
        _ => {}
    }
    let (__line, __col) = pos_to_line(__input, __state.max_err_pos);
    Err(ParseError { line: __line, column: __col, offset: __state.max_err_pos, expected: __state.expected })
}

pub fn expression<'input, T: Interner>(__input: &'input str, env: &mut Env<T>) -> ParseResult<Box<Node<Expression<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    let mut __state = ParseState::new();
    match __parse_expression(__input, &mut __state, 0, env) {
        Matched(__pos, __value) => {
            if __pos == __input.len() {
                return Ok(__value);
            }
        }
        _ => {}
    }
    let (__line, __col) = pos_to_line(__input, __state.max_err_pos);
    Err(ParseError { line: __line, column: __col, offset: __state.max_err_pos, expected: __state.expected })
}

pub fn declaration<'input, T: Interner>(__input: &'input str, env: &mut Env<T>) -> ParseResult<Node<Declaration<T::Interned>>> {
    #![allow(non_snake_case, unused)]
    let mut __state = ParseState::new();
    match __parse_declaration(__input, &mut __state, 0, env) {
        Matched(__pos, __value) => {
            if __pos == __input.len() {
                return Ok(__value);
            }
        }
        _ => {}
    }
    let (__line, __col) = pos_to_line(__input, __state.max_err_pos);
    Err(ParseError { line: __line, column: __col, offset: __state.max_err_pos, expected: __state.expected })
}

pub fn statement<'input, T: Interner>(__input: &'input str, env: &mut Env<T>) -> ParseResult<Box<Node<Statement<T::Interned>>>> {
    #![allow(non_snake_case, unused)]
    let mut __state = ParseState::new();
    match __parse_statement(__input, &mut __state, 0, env) {
        Matched(__pos, __value) => {
            if __pos == __input.len() {
                return Ok(__value);
            }
        }
        _ => {}
    }
    let (__line, __col) = pos_to_line(__input, __state.max_err_pos);
    Err(ParseError { line: __line, column: __col, offset: __state.max_err_pos, expected: __state.expected })
}

pub fn translation_unit<'input, T: Interner>(__input: &'input str, env: &mut Env<T>) -> ParseResult<TranslationUnit<T::Interned>> {
    #![allow(non_snake_case, unused)]
    let mut __state = ParseState::new();
    match __parse_translation_unit(__input, &mut __state, 0, env) {
        Matched(__pos, __value) => {
            if __pos == __input.len() {
                return Ok(__value);
            }
        }
        _ => {}
    }
    let (__line, __col) = pos_to_line(__input, __state.max_err_pos);
    Err(ParseError { line: __line, column: __col, offset: __state.max_err_pos, expected: __state.expected })
}
